{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/GersonJr/Desktop/projetos/angular/projeto-websocket/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.StompJs = {}));\n})(this, function (exports) {\n  'use strict';\n\n  /**\n   * Some byte values, used as per STOMP specifications.\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  const BYTE = {\n    // LINEFEED byte (octet 10)\n    LF: '\\x0A',\n    // NULL byte (octet 0)\n    NULL: '\\x00'\n  };\n\n  /**\n   * Frame class represents a STOMP frame.\n   *\n   * @internal\n   */\n  class FrameImpl {\n    /**\n     * Frame constructor. `command`, `headers` and `body` are available as properties.\n     *\n     * @internal\n     */\n    constructor(params) {\n      const {\n        command,\n        headers,\n        body,\n        binaryBody,\n        escapeHeaderValues,\n        skipContentLengthHeader\n      } = params;\n      this.command = command;\n      this.headers = Object.assign({}, headers || {});\n      if (binaryBody) {\n        this._binaryBody = binaryBody;\n        this.isBinaryBody = true;\n      } else {\n        this._body = body || '';\n        this.isBinaryBody = false;\n      }\n      this.escapeHeaderValues = escapeHeaderValues || false;\n      this.skipContentLengthHeader = skipContentLengthHeader || false;\n    }\n    /**\n     * body of the frame\n     */\n    get body() {\n      if (!this._body && this.isBinaryBody) {\n        this._body = new TextDecoder().decode(this._binaryBody);\n      }\n      return this._body || '';\n    }\n    /**\n     * body as Uint8Array\n     */\n    get binaryBody() {\n      if (!this._binaryBody && !this.isBinaryBody) {\n        this._binaryBody = new TextEncoder().encode(this._body);\n      }\n      // At this stage it will definitely have a valid value\n      return this._binaryBody;\n    }\n    /**\n     * deserialize a STOMP Frame from raw data.\n     *\n     * @internal\n     */\n    static fromRawFrame(rawFrame, escapeHeaderValues) {\n      const headers = {};\n      const trim = str => str.replace(/^\\s+|\\s+$/g, '');\n      // In case of repeated headers, as per standards, first value need to be used\n      for (const header of rawFrame.headers.reverse()) {\n        header.indexOf(':');\n        const key = trim(header[0]);\n        let value = trim(header[1]);\n        if (escapeHeaderValues && rawFrame.command !== 'CONNECT' && rawFrame.command !== 'CONNECTED') {\n          value = FrameImpl.hdrValueUnEscape(value);\n        }\n        headers[key] = value;\n      }\n      return new FrameImpl({\n        command: rawFrame.command,\n        headers,\n        binaryBody: rawFrame.binaryBody,\n        escapeHeaderValues\n      });\n    }\n    /**\n     * @internal\n     */\n    toString() {\n      return this.serializeCmdAndHeaders();\n    }\n    /**\n     * serialize this Frame in a format suitable to be passed to WebSocket.\n     * If the body is string the output will be string.\n     * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n     *\n     * @internal\n     */\n    serialize() {\n      const cmdAndHeaders = this.serializeCmdAndHeaders();\n      if (this.isBinaryBody) {\n        return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n      } else {\n        return cmdAndHeaders + this._body + BYTE.NULL;\n      }\n    }\n    serializeCmdAndHeaders() {\n      const lines = [this.command];\n      if (this.skipContentLengthHeader) {\n        delete this.headers['content-length'];\n      }\n      for (const name of Object.keys(this.headers || {})) {\n        const value = this.headers[name];\n        if (this.escapeHeaderValues && this.command !== 'CONNECT' && this.command !== 'CONNECTED') {\n          lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\n        } else {\n          lines.push(`${name}:${value}`);\n        }\n      }\n      if (this.isBinaryBody || !this.isBodyEmpty() && !this.skipContentLengthHeader) {\n        lines.push(`content-length:${this.bodyLength()}`);\n      }\n      return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n    }\n    isBodyEmpty() {\n      return this.bodyLength() === 0;\n    }\n    bodyLength() {\n      const binaryBody = this.binaryBody;\n      return binaryBody ? binaryBody.length : 0;\n    }\n    /**\n     * Compute the size of a UTF-8 string by counting its number of bytes\n     * (and not the number of characters composing the string)\n     */\n    static sizeOfUTF8(s) {\n      return s ? new TextEncoder().encode(s).length : 0;\n    }\n    static toUnit8Array(cmdAndHeaders, binaryBody) {\n      const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n      const nullTerminator = new Uint8Array([0]);\n      const uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n      uint8Frame.set(uint8CmdAndHeaders);\n      uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n      uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n      return uint8Frame;\n    }\n    /**\n     * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n     *\n     * @internal\n     */\n    static marshall(params) {\n      const frame = new FrameImpl(params);\n      return frame.serialize();\n    }\n    /**\n     *  Escape header values\n     */\n    static hdrValueEscape(str) {\n      return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/:/g, '\\\\c');\n    }\n    /**\n     * UnEscape header values\n     */\n    static hdrValueUnEscape(str) {\n      return str.replace(/\\\\r/g, '\\r').replace(/\\\\n/g, '\\n').replace(/\\\\c/g, ':').replace(/\\\\\\\\/g, '\\\\');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  const NULL = 0;\n  /**\n   * @internal\n   */\n  const LF = 10;\n  /**\n   * @internal\n   */\n  const CR = 13;\n  /**\n   * @internal\n   */\n  const COLON = 58;\n  /**\n   * This is an evented, rec descent parser.\n   * A stream of Octets can be passed and whenever it recognizes\n   * a complete Frame or an incoming ping it will invoke the registered callbacks.\n   *\n   * All incoming Octets are fed into _onByte function.\n   * Depending on current state the _onByte function keeps changing.\n   * Depending on the state it keeps accumulating into _token and _results.\n   * State is indicated by current value of _onByte, all states are named as _collect.\n   *\n   * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n   * imply that all lengths are considered in bytes (instead of string lengths).\n   * So, before actual parsing, if the incoming data is String it is converted to Octets.\n   * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n   *\n   * There is no peek function on the incoming data.\n   * When a state change occurs based on an Octet without consuming the Octet,\n   * the Octet, after state change, is fed again (_reinjectByte).\n   * This became possible as the state change can be determined by inspecting just one Octet.\n   *\n   * There are two modes to collect the body, if content-length header is there then it by counting Octets\n   * otherwise it is determined by NULL terminator.\n   *\n   * Following the standards, the command and headers are converted to Strings\n   * and the body is returned as Octets.\n   * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n   *\n   * This parser does not use Regular Expressions as that can only operate on Strings.\n   *\n   * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n   * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n   * is pushed.\n   *\n   * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n   * (which is protocol version specific), and convert body to text.\n   *\n   * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  class Parser {\n    constructor(onFrame, onIncomingPing) {\n      this.onFrame = onFrame;\n      this.onIncomingPing = onIncomingPing;\n      this._encoder = new TextEncoder();\n      this._decoder = new TextDecoder();\n      this._token = [];\n      this._initState();\n    }\n    parseChunk(segment, appendMissingNULLonIncoming = false) {\n      let chunk;\n      if (typeof segment === 'string') {\n        chunk = this._encoder.encode(segment);\n      } else {\n        chunk = new Uint8Array(segment);\n      }\n      // See https://github.com/stomp-js/stompjs/issues/89\n      // Remove when underlying issue is fixed.\n      //\n      // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n      if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n        const chunkWithNull = new Uint8Array(chunk.length + 1);\n        chunkWithNull.set(chunk, 0);\n        chunkWithNull[chunk.length] = 0;\n        chunk = chunkWithNull;\n      }\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < chunk.length; i++) {\n        const byte = chunk[i];\n        this._onByte(byte);\n      }\n    }\n    // The following implements a simple Rec Descent Parser.\n    // The grammar is simple and just one byte tells what should be the next state\n    _collectFrame(byte) {\n      if (byte === NULL) {\n        // Ignore\n        return;\n      }\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        // Incoming Ping\n        this.onIncomingPing();\n        return;\n      }\n      this._onByte = this._collectCommand;\n      this._reinjectByte(byte);\n    }\n    _collectCommand(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._results.command = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaders;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _collectHeaders(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._setupCollectBody();\n        return;\n      }\n      this._onByte = this._collectHeaderKey;\n      this._reinjectByte(byte);\n    }\n    _reinjectByte(byte) {\n      this._onByte(byte);\n    }\n    _collectHeaderKey(byte) {\n      if (byte === COLON) {\n        this._headerKey = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaderValue;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _collectHeaderValue(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n        this._headerKey = undefined;\n        this._onByte = this._collectHeaders;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _setupCollectBody() {\n      const contentLengthHeader = this._results.headers.filter(header => {\n        return header[0] === 'content-length';\n      })[0];\n      if (contentLengthHeader) {\n        this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n        this._onByte = this._collectBodyFixedSize;\n      } else {\n        this._onByte = this._collectBodyNullTerminated;\n      }\n    }\n    _collectBodyNullTerminated(byte) {\n      if (byte === NULL) {\n        this._retrievedBody();\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _collectBodyFixedSize(byte) {\n      // It is post decrement, so that we discard the trailing NULL octet\n      if (this._bodyBytesRemaining-- === 0) {\n        this._retrievedBody();\n        return;\n      }\n      this._consumeByte(byte);\n    }\n    _retrievedBody() {\n      this._results.binaryBody = this._consumeTokenAsRaw();\n      try {\n        this.onFrame(this._results);\n      } catch (e) {\n        console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n      }\n      this._initState();\n    }\n    // Rec Descent Parser helpers\n    _consumeByte(byte) {\n      this._token.push(byte);\n    }\n    _consumeTokenAsUTF8() {\n      return this._decoder.decode(this._consumeTokenAsRaw());\n    }\n    _consumeTokenAsRaw() {\n      const rawResult = new Uint8Array(this._token);\n      this._token = [];\n      return rawResult;\n    }\n    _initState() {\n      this._results = {\n        command: undefined,\n        headers: [],\n        binaryBody: undefined\n      };\n      this._token = [];\n      this._headerKey = undefined;\n      this._onByte = this._collectFrame;\n    }\n  }\n\n  /**\n   * Possible states for the IStompSocket\n   */\n  exports.StompSocketState = void 0;\n  (function (StompSocketState) {\n    StompSocketState[StompSocketState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    StompSocketState[StompSocketState[\"OPEN\"] = 1] = \"OPEN\";\n    StompSocketState[StompSocketState[\"CLOSING\"] = 2] = \"CLOSING\";\n    StompSocketState[StompSocketState[\"CLOSED\"] = 3] = \"CLOSED\";\n  })(exports.StompSocketState = exports.StompSocketState || (exports.StompSocketState = {}));\n  /**\n   * Possible activation state\n   */\n  exports.ActivationState = void 0;\n  (function (ActivationState) {\n    ActivationState[ActivationState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n    ActivationState[ActivationState[\"DEACTIVATING\"] = 1] = \"DEACTIVATING\";\n    ActivationState[ActivationState[\"INACTIVE\"] = 2] = \"INACTIVE\";\n  })(exports.ActivationState = exports.ActivationState || (exports.ActivationState = {}));\n\n  /**\n   * Supported STOMP versions\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class Versions {\n    /**\n     * Takes an array of versions, typical elements '1.2', '1.1', or '1.0'\n     *\n     * You will be creating an instance of this class if you want to override\n     * supported versions to be declared during STOMP handshake.\n     */\n    constructor(versions) {\n      this.versions = versions;\n    }\n    /**\n     * Used as part of CONNECT STOMP Frame\n     */\n    supportedVersions() {\n      return this.versions.join(',');\n    }\n    /**\n     * Used while creating a WebSocket\n     */\n    protocolVersions() {\n      return this.versions.map(x => `v${x.replace('.', '')}.stomp`);\n    }\n  }\n  /**\n   * Indicates protocol version 1.0\n   */\n  Versions.V1_0 = '1.0';\n  /**\n   * Indicates protocol version 1.1\n   */\n  Versions.V1_1 = '1.1';\n  /**\n   * Indicates protocol version 1.2\n   */\n  Versions.V1_2 = '1.2';\n  /**\n   * @internal\n   */\n  Versions.default = new Versions([Versions.V1_2, Versions.V1_1, Versions.V1_0]);\n\n  /**\n   * @internal\n   */\n  function augmentWebsocket(webSocket, debug) {\n    webSocket.terminate = function () {\n      const noOp = () => {};\n      // set all callbacks to no op\n      this.onerror = noOp;\n      this.onmessage = noOp;\n      this.onopen = noOp;\n      const ts = new Date();\n      const id = Math.random().toString().substring(2, 8); // A simulated id\n      const origOnClose = this.onclose;\n      // Track delay in actual closure of the socket\n      this.onclose = closeEvent => {\n        const delay = new Date().getTime() - ts.getTime();\n        debug(`Discarded socket (#${id})  closed after ${delay}ms, with code/reason: ${closeEvent.code}/${closeEvent.reason}`);\n      };\n      this.close();\n      origOnClose?.call(webSocket, {\n        code: 4001,\n        reason: `Quick discarding socket (#${id}) without waiting for the shutdown sequence.`,\n        wasClean: false\n      });\n    };\n  }\n\n  /**\n   * The STOMP protocol handler\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  class StompHandler {\n    constructor(_client, _webSocket, config) {\n      this._client = _client;\n      this._webSocket = _webSocket;\n      this._connected = false;\n      this._serverFrameHandlers = {\n        // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n        CONNECTED: frame => {\n          this.debug(`connected to server ${frame.headers.server}`);\n          this._connected = true;\n          this._connectedVersion = frame.headers.version;\n          // STOMP version 1.2 needs header values to be escaped\n          if (this._connectedVersion === Versions.V1_2) {\n            this._escapeHeaderValues = true;\n          }\n          this._setupHeartbeat(frame.headers);\n          this.onConnect(frame);\n        },\n        // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n        MESSAGE: frame => {\n          // the callback is registered when the client calls\n          // `subscribe()`.\n          // If there is no registered subscription for the received message,\n          // the default `onUnhandledMessage` callback is used that the client can set.\n          // This is useful for subscriptions that are automatically created\n          // on the browser side (e.g. [RabbitMQ's temporary\n          // queues](https://www.rabbitmq.com/stomp.html)).\n          const subscription = frame.headers.subscription;\n          const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n          // bless the frame to be a Message\n          const message = frame;\n          const client = this;\n          const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id'];\n          // add `ack()` and `nack()` methods directly to the returned frame\n          // so that a simple call to `message.ack()` can acknowledge the message.\n          message.ack = (headers = {}) => {\n            return client.ack(messageId, subscription, headers);\n          };\n          message.nack = (headers = {}) => {\n            return client.nack(messageId, subscription, headers);\n          };\n          onReceive(message);\n        },\n        // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n        RECEIPT: frame => {\n          const callback = this._receiptWatchers[frame.headers['receipt-id']];\n          if (callback) {\n            callback(frame);\n            // Server will acknowledge only once, remove the callback\n            delete this._receiptWatchers[frame.headers['receipt-id']];\n          } else {\n            this.onUnhandledReceipt(frame);\n          }\n        },\n        // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n        ERROR: frame => {\n          this.onStompError(frame);\n        }\n      };\n      // used to index subscribers\n      this._counter = 0;\n      // subscription callbacks indexed by subscriber's ID\n      this._subscriptions = {};\n      // receipt-watchers indexed by receipts-ids\n      this._receiptWatchers = {};\n      this._partialData = '';\n      this._escapeHeaderValues = false;\n      this._lastServerActivityTS = Date.now();\n      this.debug = config.debug;\n      this.stompVersions = config.stompVersions;\n      this.connectHeaders = config.connectHeaders;\n      this.disconnectHeaders = config.disconnectHeaders;\n      this.heartbeatIncoming = config.heartbeatIncoming;\n      this.heartbeatOutgoing = config.heartbeatOutgoing;\n      this.splitLargeFrames = config.splitLargeFrames;\n      this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n      this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n      this.logRawCommunication = config.logRawCommunication;\n      this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n      this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n      this.onConnect = config.onConnect;\n      this.onDisconnect = config.onDisconnect;\n      this.onStompError = config.onStompError;\n      this.onWebSocketClose = config.onWebSocketClose;\n      this.onWebSocketError = config.onWebSocketError;\n      this.onUnhandledMessage = config.onUnhandledMessage;\n      this.onUnhandledReceipt = config.onUnhandledReceipt;\n      this.onUnhandledFrame = config.onUnhandledFrame;\n    }\n    get connectedVersion() {\n      return this._connectedVersion;\n    }\n    get connected() {\n      return this._connected;\n    }\n    start() {\n      const parser = new Parser(\n      // On Frame\n      rawFrame => {\n        const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n        if (!this.logRawCommunication) {\n          this.debug(`<<< ${frame}`);\n        }\n        const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n        serverFrameHandler(frame);\n      },\n      // On Incoming Ping\n      () => {\n        this.debug('<<< PONG');\n      });\n      this._webSocket.onmessage = evt => {\n        this.debug('Received data');\n        this._lastServerActivityTS = Date.now();\n        if (this.logRawCommunication) {\n          const rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n          this.debug(`<<< ${rawChunkAsString}`);\n        }\n        parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n      };\n      this._webSocket.onclose = closeEvent => {\n        this.debug(`Connection closed to ${this._webSocket.url}`);\n        this._cleanUp();\n        this.onWebSocketClose(closeEvent);\n      };\n      this._webSocket.onerror = errorEvent => {\n        this.onWebSocketError(errorEvent);\n      };\n      this._webSocket.onopen = () => {\n        // Clone before updating\n        const connectHeaders = Object.assign({}, this.connectHeaders);\n        this.debug('Web Socket Opened...');\n        connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n        connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n        this._transmit({\n          command: 'CONNECT',\n          headers: connectHeaders\n        });\n      };\n    }\n    _setupHeartbeat(headers) {\n      if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n        return;\n      }\n      // It is valid for the server to not send this header\n      // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n      if (!headers['heart-beat']) {\n        return;\n      }\n      // heart-beat header received from the server looks like:\n      //\n      //     heart-beat: sx, sy\n      const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map(v => parseInt(v, 10));\n      if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n        const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n        this.debug(`send PING every ${ttl}ms`);\n        this._pinger = setInterval(() => {\n          if (this._webSocket.readyState === exports.StompSocketState.OPEN) {\n            this._webSocket.send(BYTE.LF);\n            this.debug('>>> PING');\n          }\n        }, ttl);\n      }\n      if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n        const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n        this.debug(`check PONG every ${ttl}ms`);\n        this._ponger = setInterval(() => {\n          const delta = Date.now() - this._lastServerActivityTS;\n          // We wait twice the TTL to be flexible on window's setInterval calls\n          if (delta > ttl * 2) {\n            this.debug(`did not receive server activity for the last ${delta}ms`);\n            this._closeOrDiscardWebsocket();\n          }\n        }, ttl);\n      }\n    }\n    _closeOrDiscardWebsocket() {\n      if (this.discardWebsocketOnCommFailure) {\n        this.debug('Discarding websocket, the underlying socket may linger for a while');\n        this.discardWebsocket();\n      } else {\n        this.debug('Issuing close on the websocket');\n        this._closeWebsocket();\n      }\n    }\n    forceDisconnect() {\n      if (this._webSocket) {\n        if (this._webSocket.readyState === exports.StompSocketState.CONNECTING || this._webSocket.readyState === exports.StompSocketState.OPEN) {\n          this._closeOrDiscardWebsocket();\n        }\n      }\n    }\n    _closeWebsocket() {\n      this._webSocket.onmessage = () => {}; // ignore messages\n      this._webSocket.close();\n    }\n    discardWebsocket() {\n      if (typeof this._webSocket.terminate !== 'function') {\n        augmentWebsocket(this._webSocket, msg => this.debug(msg));\n      }\n      // @ts-ignore - this method will be there at this stage\n      this._webSocket.terminate();\n    }\n    _transmit(params) {\n      const {\n        command,\n        headers,\n        body,\n        binaryBody,\n        skipContentLengthHeader\n      } = params;\n      const frame = new FrameImpl({\n        command,\n        headers,\n        body,\n        binaryBody,\n        escapeHeaderValues: this._escapeHeaderValues,\n        skipContentLengthHeader\n      });\n      let rawChunk = frame.serialize();\n      if (this.logRawCommunication) {\n        this.debug(`>>> ${rawChunk}`);\n      } else {\n        this.debug(`>>> ${frame}`);\n      }\n      if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n        rawChunk = new TextEncoder().encode(rawChunk);\n      }\n      if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n        this._webSocket.send(rawChunk);\n      } else {\n        let out = rawChunk;\n        while (out.length > 0) {\n          const chunk = out.substring(0, this.maxWebSocketChunkSize);\n          out = out.substring(this.maxWebSocketChunkSize);\n          this._webSocket.send(chunk);\n          this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n        }\n      }\n    }\n    dispose() {\n      if (this.connected) {\n        try {\n          // clone before updating\n          const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n          if (!disconnectHeaders.receipt) {\n            disconnectHeaders.receipt = `close-${this._counter++}`;\n          }\n          this.watchForReceipt(disconnectHeaders.receipt, frame => {\n            this._closeWebsocket();\n            this._cleanUp();\n            this.onDisconnect(frame);\n          });\n          this._transmit({\n            command: 'DISCONNECT',\n            headers: disconnectHeaders\n          });\n        } catch (error) {\n          this.debug(`Ignoring error during disconnect ${error}`);\n        }\n      } else {\n        if (this._webSocket.readyState === exports.StompSocketState.CONNECTING || this._webSocket.readyState === exports.StompSocketState.OPEN) {\n          this._closeWebsocket();\n        }\n      }\n    }\n    _cleanUp() {\n      this._connected = false;\n      if (this._pinger) {\n        clearInterval(this._pinger);\n        this._pinger = undefined;\n      }\n      if (this._ponger) {\n        clearInterval(this._ponger);\n        this._ponger = undefined;\n      }\n    }\n    publish(params) {\n      const {\n        destination,\n        headers,\n        body,\n        binaryBody,\n        skipContentLengthHeader\n      } = params;\n      const hdrs = Object.assign({\n        destination\n      }, headers);\n      this._transmit({\n        command: 'SEND',\n        headers: hdrs,\n        body,\n        binaryBody,\n        skipContentLengthHeader\n      });\n    }\n    watchForReceipt(receiptId, callback) {\n      this._receiptWatchers[receiptId] = callback;\n    }\n    subscribe(destination, callback, headers = {}) {\n      headers = Object.assign({}, headers);\n      if (!headers.id) {\n        headers.id = `sub-${this._counter++}`;\n      }\n      headers.destination = destination;\n      this._subscriptions[headers.id] = callback;\n      this._transmit({\n        command: 'SUBSCRIBE',\n        headers\n      });\n      const client = this;\n      return {\n        id: headers.id,\n        unsubscribe(hdrs) {\n          return client.unsubscribe(headers.id, hdrs);\n        }\n      };\n    }\n    unsubscribe(id, headers = {}) {\n      headers = Object.assign({}, headers);\n      delete this._subscriptions[id];\n      headers.id = id;\n      this._transmit({\n        command: 'UNSUBSCRIBE',\n        headers\n      });\n    }\n    begin(transactionId) {\n      const txId = transactionId || `tx-${this._counter++}`;\n      this._transmit({\n        command: 'BEGIN',\n        headers: {\n          transaction: txId\n        }\n      });\n      const client = this;\n      return {\n        id: txId,\n        commit() {\n          client.commit(txId);\n        },\n        abort() {\n          client.abort(txId);\n        }\n      };\n    }\n    commit(transactionId) {\n      this._transmit({\n        command: 'COMMIT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n    abort(transactionId) {\n      this._transmit({\n        command: 'ABORT',\n        headers: {\n          transaction: transactionId\n        }\n      });\n    }\n    ack(messageId, subscriptionId, headers = {}) {\n      headers = Object.assign({}, headers);\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n      headers.subscription = subscriptionId;\n      this._transmit({\n        command: 'ACK',\n        headers\n      });\n    }\n    nack(messageId, subscriptionId, headers = {}) {\n      headers = Object.assign({}, headers);\n      if (this._connectedVersion === Versions.V1_2) {\n        headers.id = messageId;\n      } else {\n        headers['message-id'] = messageId;\n      }\n      headers.subscription = subscriptionId;\n      return this._transmit({\n        command: 'NACK',\n        headers\n      });\n    }\n  }\n\n  /**\n   * STOMP Client Class.\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class Client {\n    /**\n     * Create an instance.\n     */\n    constructor(conf = {}) {\n      /**\n       * STOMP versions to attempt during STOMP handshake. By default, versions `1.2`, `1.1`, and `1.0` are attempted.\n       *\n       * Example:\n       * ```javascript\n       *        // Try only versions 1.1 and 1.0\n       *        client.stompVersions = new Versions(['1.1', '1.0'])\n       * ```\n       */\n      this.stompVersions = Versions.default;\n      /**\n       * Will retry if Stomp connection is not established in specified milliseconds.\n       * Default 0, which switches off automatic reconnection.\n       */\n      this.connectionTimeout = 0;\n      /**\n       *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n       */\n      this.reconnectDelay = 5000;\n      /**\n       * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n       */\n      this.heartbeatIncoming = 10000;\n      /**\n       * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n       */\n      this.heartbeatOutgoing = 10000;\n      /**\n       * This switches on a non-standard behavior while sending WebSocket packets.\n       * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n       * Only Java Spring brokers seem to support this mode.\n       *\n       * WebSockets, by itself, split large (text) packets,\n       * so it is not needed with a truly compliant STOMP/WebSocket broker.\n       * Setting it for such a broker will cause large messages to fail.\n       *\n       * `false` by default.\n       *\n       * Binary frames are never split.\n       */\n      this.splitLargeFrames = false;\n      /**\n       * See [splitLargeFrames]{@link Client#splitLargeFrames}.\n       * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n       */\n      this.maxWebSocketChunkSize = 8 * 1024;\n      /**\n       * Usually the\n       * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\n       * is automatically decided by type of the payload.\n       * Default is `false`, which should work with all compliant brokers.\n       *\n       * Set this flag to force binary frames.\n       */\n      this.forceBinaryWSFrames = false;\n      /**\n       * A bug in ReactNative chops a string on occurrence of a NULL.\n       * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\n       * This makes incoming WebSocket messages invalid STOMP packets.\n       * Setting this flag attempts to reverse the damage by appending a NULL.\n       * If the broker splits a large message into multiple WebSocket messages,\n       * this flag will cause data loss and abnormal termination of connection.\n       *\n       * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\n       */\n      this.appendMissingNULLonIncoming = false;\n      /**\n       * Browsers do not immediately close WebSockets when `.close` is issued.\n       * This may cause reconnection to take a significantly long time in case\n       *  of some types of failures.\n       * In case of incoming heartbeat failure, this experimental flag instructs\n       * the library to discard the socket immediately\n       * (even before it is actually closed).\n       */\n      this.discardWebsocketOnCommFailure = false;\n      /**\n       * Activation state.\n       *\n       * It will usually be ACTIVE or INACTIVE.\n       * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n       */\n      this.state = exports.ActivationState.INACTIVE;\n      // No op callbacks\n      const noOp = () => {};\n      this.debug = noOp;\n      this.beforeConnect = noOp;\n      this.onConnect = noOp;\n      this.onDisconnect = noOp;\n      this.onUnhandledMessage = noOp;\n      this.onUnhandledReceipt = noOp;\n      this.onUnhandledFrame = noOp;\n      this.onStompError = noOp;\n      this.onWebSocketClose = noOp;\n      this.onWebSocketError = noOp;\n      this.logRawCommunication = false;\n      this.onChangeState = noOp;\n      // These parameters would typically get proper values before connect is called\n      this.connectHeaders = {};\n      this._disconnectHeaders = {};\n      // Apply configuration\n      this.configure(conf);\n    }\n    /**\n     * Underlying WebSocket instance, READONLY.\n     */\n    get webSocket() {\n      return this._stompHandler?._webSocket;\n    }\n    /**\n     * Disconnection headers.\n     */\n    get disconnectHeaders() {\n      return this._disconnectHeaders;\n    }\n    set disconnectHeaders(value) {\n      this._disconnectHeaders = value;\n      if (this._stompHandler) {\n        this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n      }\n    }\n    /**\n     * `true` if there is an active connection to STOMP Broker\n     */\n    get connected() {\n      return !!this._stompHandler && this._stompHandler.connected;\n    }\n    /**\n     * version of STOMP protocol negotiated with the server, READONLY\n     */\n    get connectedVersion() {\n      return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n    }\n    /**\n     * if the client is active (connected or going to reconnect)\n     */\n    get active() {\n      return this.state === exports.ActivationState.ACTIVE;\n    }\n    _changeState(state) {\n      this.state = state;\n      this.onChangeState(state);\n    }\n    /**\n     * Update configuration.\n     */\n    configure(conf) {\n      // bulk assign all properties to this\n      Object.assign(this, conf);\n    }\n    /**\n     * Initiate the connection with the broker.\n     * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n     * it will keep trying to reconnect.\n     *\n     * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n     */\n    activate() {\n      const _activate = () => {\n        if (this.active) {\n          this.debug('Already ACTIVE, ignoring request to activate');\n          return;\n        }\n        this._changeState(exports.ActivationState.ACTIVE);\n        this._connect();\n      };\n      // if it is deactivating, wait for it to complete before activating.\n      if (this.state === exports.ActivationState.DEACTIVATING) {\n        this.debug('Waiting for deactivation to finish before activating');\n        this.deactivate().then(() => {\n          _activate();\n        });\n      } else {\n        _activate();\n      }\n    }\n    _connect() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        yield _this.beforeConnect();\n        if (_this._stompHandler) {\n          _this.debug('There is already a stompHandler, skipping the call to connect');\n          return;\n        }\n        if (!_this.active) {\n          _this.debug('Client has been marked inactive, will not attempt to connect');\n          return;\n        }\n        // setup connection watcher\n        if (_this.connectionTimeout > 0) {\n          // clear first\n          if (_this._connectionWatcher) {\n            clearTimeout(_this._connectionWatcher);\n          }\n          _this._connectionWatcher = setTimeout(() => {\n            if (_this.connected) {\n              return;\n            }\n            // Connection not established, close the underlying socket\n            // a reconnection will be attempted\n            _this.debug(`Connection not established in ${_this.connectionTimeout}ms, closing socket`);\n            _this.forceDisconnect();\n          }, _this.connectionTimeout);\n        }\n        _this.debug('Opening Web Socket...');\n        // Get the actual WebSocket (or a similar object)\n        const webSocket = _this._createWebSocket();\n        _this._stompHandler = new StompHandler(_this, webSocket, {\n          debug: _this.debug,\n          stompVersions: _this.stompVersions,\n          connectHeaders: _this.connectHeaders,\n          disconnectHeaders: _this._disconnectHeaders,\n          heartbeatIncoming: _this.heartbeatIncoming,\n          heartbeatOutgoing: _this.heartbeatOutgoing,\n          splitLargeFrames: _this.splitLargeFrames,\n          maxWebSocketChunkSize: _this.maxWebSocketChunkSize,\n          forceBinaryWSFrames: _this.forceBinaryWSFrames,\n          logRawCommunication: _this.logRawCommunication,\n          appendMissingNULLonIncoming: _this.appendMissingNULLonIncoming,\n          discardWebsocketOnCommFailure: _this.discardWebsocketOnCommFailure,\n          onConnect: frame => {\n            // Successfully connected, stop the connection watcher\n            if (_this._connectionWatcher) {\n              clearTimeout(_this._connectionWatcher);\n              _this._connectionWatcher = undefined;\n            }\n            if (!_this.active) {\n              _this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n              _this._disposeStompHandler();\n              return;\n            }\n            _this.onConnect(frame);\n          },\n          onDisconnect: frame => {\n            _this.onDisconnect(frame);\n          },\n          onStompError: frame => {\n            _this.onStompError(frame);\n          },\n          onWebSocketClose: evt => {\n            _this._stompHandler = undefined; // a new one will be created in case of a reconnect\n            if (_this.state === exports.ActivationState.DEACTIVATING) {\n              // Mark deactivation complete\n              _this._changeState(exports.ActivationState.INACTIVE);\n            }\n            // The callback is called before attempting to reconnect, this would allow the client\n            // to be `deactivated` in the callback.\n            _this.onWebSocketClose(evt);\n            if (_this.active) {\n              _this._schedule_reconnect();\n            }\n          },\n          onWebSocketError: evt => {\n            _this.onWebSocketError(evt);\n          },\n          onUnhandledMessage: message => {\n            _this.onUnhandledMessage(message);\n          },\n          onUnhandledReceipt: frame => {\n            _this.onUnhandledReceipt(frame);\n          },\n          onUnhandledFrame: frame => {\n            _this.onUnhandledFrame(frame);\n          }\n        });\n        _this._stompHandler.start();\n      })();\n    }\n    _createWebSocket() {\n      let webSocket;\n      if (this.webSocketFactory) {\n        webSocket = this.webSocketFactory();\n      } else if (this.brokerURL) {\n        webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n      } else {\n        throw new Error('Either brokerURL or webSocketFactory must be provided');\n      }\n      webSocket.binaryType = 'arraybuffer';\n      return webSocket;\n    }\n    _schedule_reconnect() {\n      if (this.reconnectDelay > 0) {\n        this.debug(`STOMP: scheduling reconnection in ${this.reconnectDelay}ms`);\n        this._reconnector = setTimeout(() => {\n          this._connect();\n        }, this.reconnectDelay);\n      }\n    }\n    /**\n     * Disconnect if connected and stop auto reconnect loop.\n     * Appropriate callbacks will be invoked if there is an underlying STOMP connection.\n     *\n     * This call is async. It will resolve immediately if there is no underlying active websocket,\n     * otherwise, it will resolve after the underlying websocket is properly disposed of.\n     *\n     * It is not an error to invoke this method more than once.\n     * Each of those would resolve on completion of deactivation.\n     *\n     * To reactivate, you can call [Client#activate]{@link Client#activate}.\n     *\n     * Experimental: pass `force: true` to immediately discard the underlying connection.\n     * This mode will skip both the STOMP and the Websocket shutdown sequences.\n     * In some cases, browsers take a long time in the Websocket shutdown\n     * if the underlying connection had gone stale.\n     * Using this mode can speed up.\n     * When this mode is used, the actual Websocket may linger for a while\n     * and the broker may not realize that the connection is no longer in use.\n     *\n     * It is possible to invoke this method initially without the `force` option\n     * and subsequently, say after a wait, with the `force` option.\n     */\n    deactivate(options = {}) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const force = options.force || false;\n        const needToDispose = _this2.active;\n        let retPromise;\n        if (_this2.state === exports.ActivationState.INACTIVE) {\n          _this2.debug(`Already INACTIVE, nothing more to do`);\n          return Promise.resolve();\n        }\n        _this2._changeState(exports.ActivationState.DEACTIVATING);\n        // Clear if a reconnection was scheduled\n        if (_this2._reconnector) {\n          clearTimeout(_this2._reconnector);\n          _this2._reconnector = undefined;\n        }\n        if (_this2._stompHandler &&\n        // @ts-ignore - if there is a _stompHandler, there is the webSocket\n        _this2.webSocket.readyState !== exports.StompSocketState.CLOSED) {\n          const origOnWebSocketClose = _this2._stompHandler.onWebSocketClose;\n          // we need to wait for the underlying websocket to close\n          retPromise = new Promise((resolve, reject) => {\n            // @ts-ignore - there is a _stompHandler\n            _this2._stompHandler.onWebSocketClose = evt => {\n              origOnWebSocketClose(evt);\n              resolve();\n            };\n          });\n        } else {\n          // indicate that auto reconnect loop should terminate\n          _this2._changeState(exports.ActivationState.INACTIVE);\n          return Promise.resolve();\n        }\n        if (force) {\n          _this2._stompHandler?.discardWebsocket();\n        } else if (needToDispose) {\n          _this2._disposeStompHandler();\n        }\n        return retPromise;\n      })();\n    }\n    /**\n     * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n     * This is different from a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n     * After forcing disconnect, automatic reconnect will be attempted.\n     * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n     */\n    forceDisconnect() {\n      if (this._stompHandler) {\n        this._stompHandler.forceDisconnect();\n      }\n    }\n    _disposeStompHandler() {\n      // Dispose STOMP Handler\n      if (this._stompHandler) {\n        this._stompHandler.dispose();\n      }\n    }\n    /**\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations.\n     *\n     * STOMP protocol specifies and suggests some headers and also allows broker-specific headers.\n     *\n     * `body` must be String.\n     * You will need to covert the payload to string in case it is not string (e.g. JSON).\n     *\n     * To send a binary message body, use `binaryBody` parameter. It should be a\n     * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n     * Sometimes brokers may not support binary frames out of the box.\n     * Please check your broker documentation.\n     *\n     * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n     * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n     * For binary messages, `content-length` header is always added.\n     *\n     * Caution: The broker will, most likely, report an error and disconnect\n     * if the message body has NULL octet(s) and `content-length` header is missing.\n     *\n     * ```javascript\n     *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n     *\n     *        // Only destination is mandatory parameter\n     *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n     *\n     *        // Skip content-length header in the frame to the broker\n     *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n     *\n     *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n     *        // setting content-type header is not mandatory, however a good practice\n     *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n     *                         headers: {'content-type': 'application/octet-stream'}});\n     * ```\n     */\n    publish(params) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.publish(params);\n    }\n    _checkConnection() {\n      if (!this.connected) {\n        throw new TypeError('There is no underlying STOMP connection');\n      }\n    }\n    /**\n     * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n     * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n     * The value (say receipt-id) for this header needs to be unique for each use.\n     * Typically, a sequence, a UUID, a random number or a combination may be used.\n     *\n     * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n     * The operation needs to be matched based on the value of the receipt-id.\n     *\n     * This method allows watching for a receipt and invoking the callback\n     *  when the corresponding receipt has been received.\n     *\n     * The actual {@link IFrame} will be passed as parameter to the callback.\n     *\n     * Example:\n     * ```javascript\n     *        // Subscribing with acknowledgement\n     *        let receiptId = randomText();\n     *\n     *        client.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *\n     *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n     *\n     *\n     *        // Publishing with acknowledgement\n     *        receiptId = randomText();\n     *\n     *        client.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n     * ```\n     */\n    watchForReceipt(receiptId, callback) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.watchForReceipt(receiptId, callback);\n    }\n    /**\n     * Subscribe to a STOMP Broker location. The callback will be invoked for each\n     * received message with the {@link IMessage} as argument.\n     *\n     * Note: The library will generate a unique ID if there is none provided in the headers.\n     *       To use your own ID, pass it using the `headers` argument.\n     *\n     * ```javascript\n     *        callback = function(message) {\n     *        // called when the client receives a STOMP message from the server\n     *          if (message.body) {\n     *            alert(\"got message with body \" + message.body)\n     *          } else {\n     *            alert(\"got empty message\");\n     *          }\n     *        });\n     *\n     *        var subscription = client.subscribe(\"/queue/test\", callback);\n     *\n     *        // Explicit subscription id\n     *        var mySubId = 'my-subscription-id-001';\n     *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n     * ```\n     */\n    subscribe(destination, callback, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      return this._stompHandler.subscribe(destination, callback, headers);\n    }\n    /**\n     * It is preferable to unsubscribe from a subscription by calling\n     * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n     *\n     * ```javascript\n     *        var subscription = client.subscribe(destination, onmessage);\n     *        // ...\n     *        subscription.unsubscribe();\n     * ```\n     *\n     * See: https://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n     */\n    unsubscribe(id, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.unsubscribe(id, headers);\n    }\n    /**\n     * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\n     * and [abort]{@link ITransaction#abort}.\n     *\n     * `transactionId` is optional, if not passed the library will generate it internally.\n     */\n    begin(transactionId) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      return this._stompHandler.begin(transactionId);\n    }\n    /**\n     * Commit a transaction.\n     *\n     * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\n     * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n     *\n     * ```javascript\n     *        var tx = client.begin(txId);\n     *        //...\n     *        tx.commit();\n     * ```\n     */\n    commit(transactionId) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.commit(transactionId);\n    }\n    /**\n     * Abort a transaction.\n     * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\n     * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n     *\n     * ```javascript\n     *        var tx = client.begin(txId);\n     *        //...\n     *        tx.abort();\n     * ```\n     */\n    abort(transactionId) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.abort(transactionId);\n    }\n    /**\n     * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\n     * on the {@link IMessage} handled by a subscription callback:\n     *\n     * ```javascript\n     *        var callback = function (message) {\n     *          // process the message\n     *          // acknowledge it\n     *          message.ack();\n     *        };\n     *        client.subscribe(destination, callback, {'ack': 'client'});\n     * ```\n     */\n    ack(messageId, subscriptionId, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.ack(messageId, subscriptionId, headers);\n    }\n    /**\n     * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\n     * on the {@link IMessage} handled by a subscription callback:\n     *\n     * ```javascript\n     *        var callback = function (message) {\n     *          // process the message\n     *          // an error occurs, nack it\n     *          message.nack();\n     *        };\n     *        client.subscribe(destination, callback, {'ack': 'client'});\n     * ```\n     */\n    nack(messageId, subscriptionId, headers = {}) {\n      this._checkConnection();\n      // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n      this._stompHandler.nack(messageId, subscriptionId, headers);\n    }\n  }\n\n  /**\n   * Configuration options for STOMP Client, each key corresponds to\n   * field by the same name in {@link Client}. This can be passed to\n   * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class StompConfig {}\n\n  /**\n   * STOMP headers. Many functions calls will accept headers as parameters.\n   * The headers sent by Broker will be available as [IFrame#headers]{@link IFrame#headers}.\n   *\n   * `key` and `value` must be valid strings.\n   * In addition, `key` must not contain `CR`, `LF`, or `:`.\n   *\n   * Part of `@stomp/stompjs`.\n   */\n  class StompHeaders {}\n\n  /**\n   * Part of `@stomp/stompjs`.\n   *\n   * @internal\n   */\n  class HeartbeatInfo {\n    constructor(client) {\n      this.client = client;\n    }\n    get outgoing() {\n      return this.client.heartbeatOutgoing;\n    }\n    set outgoing(value) {\n      this.client.heartbeatOutgoing = value;\n    }\n    get incoming() {\n      return this.client.heartbeatIncoming;\n    }\n    set incoming(value) {\n      this.client.heartbeatIncoming = value;\n    }\n  }\n\n  /**\n   * Available for backward compatibility, please shift to using {@link Client}.\n   *\n   * **Deprecated**\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * To upgrade, please follow the [Upgrade Guide](https://stomp-js.github.io/guide/stompjs/upgrading-stompjs.html)\n   */\n  class CompatClient extends Client {\n    /**\n     * Available for backward compatibility, please shift to using {@link Client}\n     * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\n     *\n     * **Deprecated**\n     *\n     * @internal\n     */\n    constructor(webSocketFactory) {\n      super();\n      /**\n       * It is no op now. No longer needed. Large packets work out of the box.\n       */\n      this.maxWebSocketFrameSize = 16 * 1024;\n      this._heartbeatInfo = new HeartbeatInfo(this);\n      this.reconnect_delay = 0;\n      this.webSocketFactory = webSocketFactory;\n      // Default from previous version\n      this.debug = (...message) => {\n        console.log(...message);\n      };\n    }\n    _parseConnect(...args) {\n      let closeEventCallback;\n      let connectCallback;\n      let errorCallback;\n      let headers = {};\n      if (args.length < 2) {\n        throw new Error('Connect requires at least 2 arguments');\n      }\n      if (typeof args[1] === 'function') {\n        [headers, connectCallback, errorCallback, closeEventCallback] = args;\n      } else {\n        switch (args.length) {\n          case 6:\n            [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback, headers.host] = args;\n            break;\n          default:\n            [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback] = args;\n        }\n      }\n      return [headers, connectCallback, errorCallback, closeEventCallback];\n    }\n    /**\n     * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\n     *\n     * **Deprecated**\n     *\n     * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n     * version with headers to pass your broker specific options.\n     *\n     * overloads:\n     * - connect(headers, connectCallback)\n     * - connect(headers, connectCallback, errorCallback)\n     * - connect(login, passcode, connectCallback)\n     * - connect(login, passcode, connectCallback, errorCallback)\n     * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n     * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n     *\n     * params:\n     * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\n     * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\n     * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\n     * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\n     * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n     * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\n     * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n     *\n     * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n     */\n    connect(...args) {\n      const out = this._parseConnect(...args);\n      if (out[0]) {\n        this.connectHeaders = out[0];\n      }\n      if (out[1]) {\n        this.onConnect = out[1];\n      }\n      if (out[2]) {\n        this.onStompError = out[2];\n      }\n      if (out[3]) {\n        this.onWebSocketClose = out[3];\n      }\n      super.activate();\n    }\n    /**\n     * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\n     *\n     * **Deprecated**\n     *\n     * See:\n     * [Client#onDisconnect]{@link Client#onDisconnect}, and\n     * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\n     *\n     * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n     */\n    disconnect(disconnectCallback, headers = {}) {\n      if (disconnectCallback) {\n        this.onDisconnect = disconnectCallback;\n      }\n      this.disconnectHeaders = headers;\n      super.deactivate();\n    }\n    /**\n     * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\n     *\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations. The headers will, typically, be available to the subscriber.\n     * However, there may be special purpose headers corresponding to your STOMP broker.\n     *\n     *  **Deprecated**, use [Client#publish]{@link Client#publish}\n     *\n     * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n     *\n     * ```javascript\n     *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n     *\n     *        // If you want to send a message with a body, you must also pass the headers argument.\n     *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n     * ```\n     *\n     * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n     */\n    send(destination, headers = {}, body = '') {\n      headers = Object.assign({}, headers);\n      const skipContentLengthHeader = headers['content-length'] === false;\n      if (skipContentLengthHeader) {\n        delete headers['content-length'];\n      }\n      this.publish({\n        destination,\n        headers: headers,\n        body,\n        skipContentLengthHeader\n      });\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\n     *\n     * **Deprecated**\n     */\n    set reconnect_delay(value) {\n      this.reconnectDelay = value;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\n     *\n     * **Deprecated**\n     */\n    get ws() {\n      return this.webSocket;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\n     *\n     * **Deprecated**\n     */\n    get version() {\n      return this.connectedVersion;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n     *\n     * **Deprecated**\n     */\n    get onreceive() {\n      return this.onUnhandledMessage;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n     *\n     * **Deprecated**\n     */\n    set onreceive(value) {\n      this.onUnhandledMessage = value;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n     * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\n     *\n     * **Deprecated**\n     */\n    get onreceipt() {\n      return this.onUnhandledReceipt;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n     *\n     * **Deprecated**\n     */\n    set onreceipt(value) {\n      this.onUnhandledReceipt = value;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n     * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n     *\n     * **Deprecated**\n     */\n    get heartbeat() {\n      return this._heartbeatInfo;\n    }\n    /**\n     * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n     * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n     *\n     * **Deprecated**\n     */\n    set heartbeat(value) {\n      this.heartbeatIncoming = value.incoming;\n      this.heartbeatOutgoing = value.outgoing;\n    }\n  }\n\n  /**\n   * STOMP Class, acts like a factory to create {@link Client}.\n   *\n   * Part of `@stomp/stompjs`.\n   *\n   * **Deprecated**\n   *\n   * It will be removed in next major version. Please switch to {@link Client}.\n   */\n  class Stomp {\n    /**\n     * This method creates a WebSocket client that is connected to\n     * the STOMP server located at the url.\n     *\n     * ```javascript\n     *        var url = \"ws://localhost:61614/stomp\";\n     *        var client = Stomp.client(url);\n     * ```\n     *\n     * **Deprecated**\n     *\n     * It will be removed in next major version. Please switch to {@link Client}\n     * using [Client#brokerURL]{@link Client#brokerURL}.\n     */\n    static client(url, protocols) {\n      // This is a hack to allow another implementation than the standard\n      // HTML5 WebSocket class.\n      //\n      // It is possible to use another class by calling\n      //\n      //     Stomp.WebSocketClass = MozWebSocket\n      //\n      // *prior* to call `Stomp.client()`.\n      //\n      // This hack is deprecated and `Stomp.over()` method should be used\n      // instead.\n      // See remarks on the function Stomp.over\n      if (protocols == null) {\n        protocols = Versions.default.protocolVersions();\n      }\n      const wsFn = () => {\n        const klass = Stomp.WebSocketClass || WebSocket;\n        return new klass(url, protocols);\n      };\n      return new CompatClient(wsFn);\n    }\n    /**\n     * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\n     * specify the WebSocket to use (either a standard HTML5 WebSocket or\n     * a similar object).\n     *\n     * In order to support reconnection, the function Client._connect should be callable more than once.\n     * While reconnecting\n     * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n     * alternatively allows passing a function that should return a new instance of the underlying socket.\n     *\n     * ```javascript\n     *        var client = Stomp.over(function(){\n     *          return new WebSocket('ws://localhost:15674/ws')\n     *        });\n     * ```\n     *\n     * **Deprecated**\n     *\n     * It will be removed in next major version. Please switch to {@link Client}\n     * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n     */\n    static over(ws) {\n      let wsFn;\n      if (typeof ws === 'function') {\n        wsFn = ws;\n      } else {\n        console.warn('Stomp.over did not receive a factory, auto reconnect will not work. ' + 'Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over');\n        wsFn = () => ws;\n      }\n      return new CompatClient(wsFn);\n    }\n  }\n  /**\n   * In case you need to use a non standard class for WebSocket.\n   *\n   * For example when using within NodeJS environment:\n   *\n   * ```javascript\n   *        StompJs = require('../../esm5/');\n   *        Stomp = StompJs.Stomp;\n   *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\n   * ```\n   *\n   * **Deprecated**\n   *\n   *\n   * It will be removed in next major version. Please switch to {@link Client}\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n   */\n  // tslint:disable-next-line:variable-name\n  Stomp.WebSocketClass = null;\n  exports.Client = Client;\n  exports.CompatClient = CompatClient;\n  exports.FrameImpl = FrameImpl;\n  exports.Parser = Parser;\n  exports.Stomp = Stomp;\n  exports.StompConfig = StompConfig;\n  exports.StompHeaders = StompHeaders;\n  exports.Versions = Versions;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","StompJs","BYTE","LF","NULL","FrameImpl","constructor","params","command","headers","body","binaryBody","escapeHeaderValues","skipContentLengthHeader","Object","assign","_binaryBody","isBinaryBody","_body","TextDecoder","decode","TextEncoder","encode","fromRawFrame","rawFrame","trim","str","replace","header","reverse","indexOf","key","value","hdrValueUnEscape","toString","serializeCmdAndHeaders","serialize","cmdAndHeaders","toUnit8Array","buffer","lines","name","keys","push","hdrValueEscape","isBodyEmpty","bodyLength","join","length","sizeOfUTF8","s","uint8CmdAndHeaders","nullTerminator","Uint8Array","uint8Frame","set","marshall","frame","CR","COLON","Parser","onFrame","onIncomingPing","_encoder","_decoder","_token","_initState","parseChunk","segment","appendMissingNULLonIncoming","chunk","chunkWithNull","i","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_setupCollectBody","_collectHeaderKey","_headerKey","_collectHeaderValue","undefined","contentLengthHeader","filter","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","_consumeTokenAsRaw","e","console","log","rawResult","StompSocketState","ActivationState","Versions","versions","supportedVersions","protocolVersions","map","x","V1_0","V1_1","V1_2","default","augmentWebsocket","webSocket","debug","terminate","noOp","onerror","onmessage","onopen","ts","Date","id","Math","random","substring","origOnClose","onclose","closeEvent","delay","getTime","code","reason","close","call","wasClean","StompHandler","_client","_webSocket","config","_connected","_serverFrameHandlers","CONNECTED","server","_connectedVersion","version","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","message","client","messageId","ack","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","now","stompVersions","connectHeaders","disconnectHeaders","heartbeatIncoming","heartbeatOutgoing","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","logRawCommunication","discardWebsocketOnCommFailure","onDisconnect","onWebSocketClose","onWebSocketError","onUnhandledFrame","connectedVersion","connected","start","parser","serverFrameHandler","evt","rawChunkAsString","data","ArrayBuffer","url","_cleanUp","errorEvent","_transmit","serverOutgoing","serverIncoming","split","v","ttl","max","_pinger","setInterval","readyState","OPEN","send","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocket","_closeWebsocket","forceDisconnect","CONNECTING","msg","rawChunk","out","dispose","receipt","watchForReceipt","error","clearInterval","publish","destination","hdrs","receiptId","subscribe","unsubscribe","begin","transactionId","txId","transaction","commit","abort","subscriptionId","Client","conf","connectionTimeout","reconnectDelay","state","INACTIVE","beforeConnect","onChangeState","_disconnectHeaders","configure","_stompHandler","active","ACTIVE","_changeState","activate","_activate","_connect","DEACTIVATING","deactivate","then","_this","_asyncToGenerator","_connectionWatcher","clearTimeout","setTimeout","_createWebSocket","_disposeStompHandler","_schedule_reconnect","webSocketFactory","brokerURL","WebSocket","Error","binaryType","_reconnector","options","_this2","force","needToDispose","retPromise","Promise","resolve","CLOSED","origOnWebSocketClose","reject","_checkConnection","TypeError","StompConfig","StompHeaders","HeartbeatInfo","outgoing","incoming","CompatClient","maxWebSocketFrameSize","_heartbeatInfo","reconnect_delay","_parseConnect","args","closeEventCallback","connectCallback","errorCallback","login","passcode","host","connect","disconnect","disconnectCallback","ws","onreceive","onreceipt","heartbeat","Stomp","protocols","wsFn","klass","WebSocketClass","over","warn"],"sources":["C:/Users/GersonJr/Desktop/projetos/angular/projeto-websocket/node_modules/@stomp/stompjs/bundles/stomp.umd.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.StompJs = {}));\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * Some byte values, used as per STOMP specifications.\n     *\n     * Part of `@stomp/stompjs`.\n     *\n     * @internal\n     */\n    const BYTE = {\n        // LINEFEED byte (octet 10)\n        LF: '\\x0A',\n        // NULL byte (octet 0)\n        NULL: '\\x00',\n    };\n\n    /**\n     * Frame class represents a STOMP frame.\n     *\n     * @internal\n     */\n    class FrameImpl {\n        /**\n         * Frame constructor. `command`, `headers` and `body` are available as properties.\n         *\n         * @internal\n         */\n        constructor(params) {\n            const { command, headers, body, binaryBody, escapeHeaderValues, skipContentLengthHeader, } = params;\n            this.command = command;\n            this.headers = Object.assign({}, headers || {});\n            if (binaryBody) {\n                this._binaryBody = binaryBody;\n                this.isBinaryBody = true;\n            }\n            else {\n                this._body = body || '';\n                this.isBinaryBody = false;\n            }\n            this.escapeHeaderValues = escapeHeaderValues || false;\n            this.skipContentLengthHeader = skipContentLengthHeader || false;\n        }\n        /**\n         * body of the frame\n         */\n        get body() {\n            if (!this._body && this.isBinaryBody) {\n                this._body = new TextDecoder().decode(this._binaryBody);\n            }\n            return this._body || '';\n        }\n        /**\n         * body as Uint8Array\n         */\n        get binaryBody() {\n            if (!this._binaryBody && !this.isBinaryBody) {\n                this._binaryBody = new TextEncoder().encode(this._body);\n            }\n            // At this stage it will definitely have a valid value\n            return this._binaryBody;\n        }\n        /**\n         * deserialize a STOMP Frame from raw data.\n         *\n         * @internal\n         */\n        static fromRawFrame(rawFrame, escapeHeaderValues) {\n            const headers = {};\n            const trim = (str) => str.replace(/^\\s+|\\s+$/g, '');\n            // In case of repeated headers, as per standards, first value need to be used\n            for (const header of rawFrame.headers.reverse()) {\n                header.indexOf(':');\n                const key = trim(header[0]);\n                let value = trim(header[1]);\n                if (escapeHeaderValues &&\n                    rawFrame.command !== 'CONNECT' &&\n                    rawFrame.command !== 'CONNECTED') {\n                    value = FrameImpl.hdrValueUnEscape(value);\n                }\n                headers[key] = value;\n            }\n            return new FrameImpl({\n                command: rawFrame.command,\n                headers,\n                binaryBody: rawFrame.binaryBody,\n                escapeHeaderValues,\n            });\n        }\n        /**\n         * @internal\n         */\n        toString() {\n            return this.serializeCmdAndHeaders();\n        }\n        /**\n         * serialize this Frame in a format suitable to be passed to WebSocket.\n         * If the body is string the output will be string.\n         * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n         *\n         * @internal\n         */\n        serialize() {\n            const cmdAndHeaders = this.serializeCmdAndHeaders();\n            if (this.isBinaryBody) {\n                return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n            }\n            else {\n                return cmdAndHeaders + this._body + BYTE.NULL;\n            }\n        }\n        serializeCmdAndHeaders() {\n            const lines = [this.command];\n            if (this.skipContentLengthHeader) {\n                delete this.headers['content-length'];\n            }\n            for (const name of Object.keys(this.headers || {})) {\n                const value = this.headers[name];\n                if (this.escapeHeaderValues &&\n                    this.command !== 'CONNECT' &&\n                    this.command !== 'CONNECTED') {\n                    lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\n                }\n                else {\n                    lines.push(`${name}:${value}`);\n                }\n            }\n            if (this.isBinaryBody ||\n                (!this.isBodyEmpty() && !this.skipContentLengthHeader)) {\n                lines.push(`content-length:${this.bodyLength()}`);\n            }\n            return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\n        }\n        isBodyEmpty() {\n            return this.bodyLength() === 0;\n        }\n        bodyLength() {\n            const binaryBody = this.binaryBody;\n            return binaryBody ? binaryBody.length : 0;\n        }\n        /**\n         * Compute the size of a UTF-8 string by counting its number of bytes\n         * (and not the number of characters composing the string)\n         */\n        static sizeOfUTF8(s) {\n            return s ? new TextEncoder().encode(s).length : 0;\n        }\n        static toUnit8Array(cmdAndHeaders, binaryBody) {\n            const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n            const nullTerminator = new Uint8Array([0]);\n            const uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n            uint8Frame.set(uint8CmdAndHeaders);\n            uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n            uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n            return uint8Frame;\n        }\n        /**\n         * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n         *\n         * @internal\n         */\n        static marshall(params) {\n            const frame = new FrameImpl(params);\n            return frame.serialize();\n        }\n        /**\n         *  Escape header values\n         */\n        static hdrValueEscape(str) {\n            return str\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r/g, '\\\\r')\n                .replace(/\\n/g, '\\\\n')\n                .replace(/:/g, '\\\\c');\n        }\n        /**\n         * UnEscape header values\n         */\n        static hdrValueUnEscape(str) {\n            return str\n                .replace(/\\\\r/g, '\\r')\n                .replace(/\\\\n/g, '\\n')\n                .replace(/\\\\c/g, ':')\n                .replace(/\\\\\\\\/g, '\\\\');\n        }\n    }\n\n    /**\n     * @internal\n     */\n    const NULL = 0;\n    /**\n     * @internal\n     */\n    const LF = 10;\n    /**\n     * @internal\n     */\n    const CR = 13;\n    /**\n     * @internal\n     */\n    const COLON = 58;\n    /**\n     * This is an evented, rec descent parser.\n     * A stream of Octets can be passed and whenever it recognizes\n     * a complete Frame or an incoming ping it will invoke the registered callbacks.\n     *\n     * All incoming Octets are fed into _onByte function.\n     * Depending on current state the _onByte function keeps changing.\n     * Depending on the state it keeps accumulating into _token and _results.\n     * State is indicated by current value of _onByte, all states are named as _collect.\n     *\n     * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n     * imply that all lengths are considered in bytes (instead of string lengths).\n     * So, before actual parsing, if the incoming data is String it is converted to Octets.\n     * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n     *\n     * There is no peek function on the incoming data.\n     * When a state change occurs based on an Octet without consuming the Octet,\n     * the Octet, after state change, is fed again (_reinjectByte).\n     * This became possible as the state change can be determined by inspecting just one Octet.\n     *\n     * There are two modes to collect the body, if content-length header is there then it by counting Octets\n     * otherwise it is determined by NULL terminator.\n     *\n     * Following the standards, the command and headers are converted to Strings\n     * and the body is returned as Octets.\n     * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n     *\n     * This parser does not use Regular Expressions as that can only operate on Strings.\n     *\n     * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n     * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n     * is pushed.\n     *\n     * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n     * (which is protocol version specific), and convert body to text.\n     *\n     * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n     *\n     * Part of `@stomp/stompjs`.\n     *\n     * @internal\n     */\n    class Parser {\n        constructor(onFrame, onIncomingPing) {\n            this.onFrame = onFrame;\n            this.onIncomingPing = onIncomingPing;\n            this._encoder = new TextEncoder();\n            this._decoder = new TextDecoder();\n            this._token = [];\n            this._initState();\n        }\n        parseChunk(segment, appendMissingNULLonIncoming = false) {\n            let chunk;\n            if (typeof segment === 'string') {\n                chunk = this._encoder.encode(segment);\n            }\n            else {\n                chunk = new Uint8Array(segment);\n            }\n            // See https://github.com/stomp-js/stompjs/issues/89\n            // Remove when underlying issue is fixed.\n            //\n            // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n            if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n                const chunkWithNull = new Uint8Array(chunk.length + 1);\n                chunkWithNull.set(chunk, 0);\n                chunkWithNull[chunk.length] = 0;\n                chunk = chunkWithNull;\n            }\n            // tslint:disable-next-line:prefer-for-of\n            for (let i = 0; i < chunk.length; i++) {\n                const byte = chunk[i];\n                this._onByte(byte);\n            }\n        }\n        // The following implements a simple Rec Descent Parser.\n        // The grammar is simple and just one byte tells what should be the next state\n        _collectFrame(byte) {\n            if (byte === NULL) {\n                // Ignore\n                return;\n            }\n            if (byte === CR) {\n                // Ignore CR\n                return;\n            }\n            if (byte === LF) {\n                // Incoming Ping\n                this.onIncomingPing();\n                return;\n            }\n            this._onByte = this._collectCommand;\n            this._reinjectByte(byte);\n        }\n        _collectCommand(byte) {\n            if (byte === CR) {\n                // Ignore CR\n                return;\n            }\n            if (byte === LF) {\n                this._results.command = this._consumeTokenAsUTF8();\n                this._onByte = this._collectHeaders;\n                return;\n            }\n            this._consumeByte(byte);\n        }\n        _collectHeaders(byte) {\n            if (byte === CR) {\n                // Ignore CR\n                return;\n            }\n            if (byte === LF) {\n                this._setupCollectBody();\n                return;\n            }\n            this._onByte = this._collectHeaderKey;\n            this._reinjectByte(byte);\n        }\n        _reinjectByte(byte) {\n            this._onByte(byte);\n        }\n        _collectHeaderKey(byte) {\n            if (byte === COLON) {\n                this._headerKey = this._consumeTokenAsUTF8();\n                this._onByte = this._collectHeaderValue;\n                return;\n            }\n            this._consumeByte(byte);\n        }\n        _collectHeaderValue(byte) {\n            if (byte === CR) {\n                // Ignore CR\n                return;\n            }\n            if (byte === LF) {\n                this._results.headers.push([\n                    this._headerKey,\n                    this._consumeTokenAsUTF8(),\n                ]);\n                this._headerKey = undefined;\n                this._onByte = this._collectHeaders;\n                return;\n            }\n            this._consumeByte(byte);\n        }\n        _setupCollectBody() {\n            const contentLengthHeader = this._results.headers.filter((header) => {\n                return header[0] === 'content-length';\n            })[0];\n            if (contentLengthHeader) {\n                this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n                this._onByte = this._collectBodyFixedSize;\n            }\n            else {\n                this._onByte = this._collectBodyNullTerminated;\n            }\n        }\n        _collectBodyNullTerminated(byte) {\n            if (byte === NULL) {\n                this._retrievedBody();\n                return;\n            }\n            this._consumeByte(byte);\n        }\n        _collectBodyFixedSize(byte) {\n            // It is post decrement, so that we discard the trailing NULL octet\n            if (this._bodyBytesRemaining-- === 0) {\n                this._retrievedBody();\n                return;\n            }\n            this._consumeByte(byte);\n        }\n        _retrievedBody() {\n            this._results.binaryBody = this._consumeTokenAsRaw();\n            try {\n                this.onFrame(this._results);\n            }\n            catch (e) {\n                console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n            }\n            this._initState();\n        }\n        // Rec Descent Parser helpers\n        _consumeByte(byte) {\n            this._token.push(byte);\n        }\n        _consumeTokenAsUTF8() {\n            return this._decoder.decode(this._consumeTokenAsRaw());\n        }\n        _consumeTokenAsRaw() {\n            const rawResult = new Uint8Array(this._token);\n            this._token = [];\n            return rawResult;\n        }\n        _initState() {\n            this._results = {\n                command: undefined,\n                headers: [],\n                binaryBody: undefined,\n            };\n            this._token = [];\n            this._headerKey = undefined;\n            this._onByte = this._collectFrame;\n        }\n    }\n\n    /**\n     * Possible states for the IStompSocket\n     */\n    exports.StompSocketState = void 0;\n    (function (StompSocketState) {\n        StompSocketState[StompSocketState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n        StompSocketState[StompSocketState[\"OPEN\"] = 1] = \"OPEN\";\n        StompSocketState[StompSocketState[\"CLOSING\"] = 2] = \"CLOSING\";\n        StompSocketState[StompSocketState[\"CLOSED\"] = 3] = \"CLOSED\";\n    })(exports.StompSocketState = exports.StompSocketState || (exports.StompSocketState = {}));\n    /**\n     * Possible activation state\n     */\n    exports.ActivationState = void 0;\n    (function (ActivationState) {\n        ActivationState[ActivationState[\"ACTIVE\"] = 0] = \"ACTIVE\";\n        ActivationState[ActivationState[\"DEACTIVATING\"] = 1] = \"DEACTIVATING\";\n        ActivationState[ActivationState[\"INACTIVE\"] = 2] = \"INACTIVE\";\n    })(exports.ActivationState = exports.ActivationState || (exports.ActivationState = {}));\n\n    /**\n     * Supported STOMP versions\n     *\n     * Part of `@stomp/stompjs`.\n     */\n    class Versions {\n        /**\n         * Takes an array of versions, typical elements '1.2', '1.1', or '1.0'\n         *\n         * You will be creating an instance of this class if you want to override\n         * supported versions to be declared during STOMP handshake.\n         */\n        constructor(versions) {\n            this.versions = versions;\n        }\n        /**\n         * Used as part of CONNECT STOMP Frame\n         */\n        supportedVersions() {\n            return this.versions.join(',');\n        }\n        /**\n         * Used while creating a WebSocket\n         */\n        protocolVersions() {\n            return this.versions.map(x => `v${x.replace('.', '')}.stomp`);\n        }\n    }\n    /**\n     * Indicates protocol version 1.0\n     */\n    Versions.V1_0 = '1.0';\n    /**\n     * Indicates protocol version 1.1\n     */\n    Versions.V1_1 = '1.1';\n    /**\n     * Indicates protocol version 1.2\n     */\n    Versions.V1_2 = '1.2';\n    /**\n     * @internal\n     */\n    Versions.default = new Versions([\n        Versions.V1_2,\n        Versions.V1_1,\n        Versions.V1_0,\n    ]);\n\n    /**\n     * @internal\n     */\n    function augmentWebsocket(webSocket, debug) {\n        webSocket.terminate = function () {\n            const noOp = () => { };\n            // set all callbacks to no op\n            this.onerror = noOp;\n            this.onmessage = noOp;\n            this.onopen = noOp;\n            const ts = new Date();\n            const id = Math.random().toString().substring(2, 8); // A simulated id\n            const origOnClose = this.onclose;\n            // Track delay in actual closure of the socket\n            this.onclose = closeEvent => {\n                const delay = new Date().getTime() - ts.getTime();\n                debug(`Discarded socket (#${id})  closed after ${delay}ms, with code/reason: ${closeEvent.code}/${closeEvent.reason}`);\n            };\n            this.close();\n            origOnClose?.call(webSocket, {\n                code: 4001,\n                reason: `Quick discarding socket (#${id}) without waiting for the shutdown sequence.`,\n                wasClean: false,\n            });\n        };\n    }\n\n    /**\n     * The STOMP protocol handler\n     *\n     * Part of `@stomp/stompjs`.\n     *\n     * @internal\n     */\n    class StompHandler {\n        constructor(_client, _webSocket, config) {\n            this._client = _client;\n            this._webSocket = _webSocket;\n            this._connected = false;\n            this._serverFrameHandlers = {\n                // [CONNECTED Frame](https://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n                CONNECTED: frame => {\n                    this.debug(`connected to server ${frame.headers.server}`);\n                    this._connected = true;\n                    this._connectedVersion = frame.headers.version;\n                    // STOMP version 1.2 needs header values to be escaped\n                    if (this._connectedVersion === Versions.V1_2) {\n                        this._escapeHeaderValues = true;\n                    }\n                    this._setupHeartbeat(frame.headers);\n                    this.onConnect(frame);\n                },\n                // [MESSAGE Frame](https://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n                MESSAGE: frame => {\n                    // the callback is registered when the client calls\n                    // `subscribe()`.\n                    // If there is no registered subscription for the received message,\n                    // the default `onUnhandledMessage` callback is used that the client can set.\n                    // This is useful for subscriptions that are automatically created\n                    // on the browser side (e.g. [RabbitMQ's temporary\n                    // queues](https://www.rabbitmq.com/stomp.html)).\n                    const subscription = frame.headers.subscription;\n                    const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\n                    // bless the frame to be a Message\n                    const message = frame;\n                    const client = this;\n                    const messageId = this._connectedVersion === Versions.V1_2\n                        ? message.headers.ack\n                        : message.headers['message-id'];\n                    // add `ack()` and `nack()` methods directly to the returned frame\n                    // so that a simple call to `message.ack()` can acknowledge the message.\n                    message.ack = (headers = {}) => {\n                        return client.ack(messageId, subscription, headers);\n                    };\n                    message.nack = (headers = {}) => {\n                        return client.nack(messageId, subscription, headers);\n                    };\n                    onReceive(message);\n                },\n                // [RECEIPT Frame](https://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n                RECEIPT: frame => {\n                    const callback = this._receiptWatchers[frame.headers['receipt-id']];\n                    if (callback) {\n                        callback(frame);\n                        // Server will acknowledge only once, remove the callback\n                        delete this._receiptWatchers[frame.headers['receipt-id']];\n                    }\n                    else {\n                        this.onUnhandledReceipt(frame);\n                    }\n                },\n                // [ERROR Frame](https://stomp.github.com/stomp-specification-1.2.html#ERROR)\n                ERROR: frame => {\n                    this.onStompError(frame);\n                },\n            };\n            // used to index subscribers\n            this._counter = 0;\n            // subscription callbacks indexed by subscriber's ID\n            this._subscriptions = {};\n            // receipt-watchers indexed by receipts-ids\n            this._receiptWatchers = {};\n            this._partialData = '';\n            this._escapeHeaderValues = false;\n            this._lastServerActivityTS = Date.now();\n            this.debug = config.debug;\n            this.stompVersions = config.stompVersions;\n            this.connectHeaders = config.connectHeaders;\n            this.disconnectHeaders = config.disconnectHeaders;\n            this.heartbeatIncoming = config.heartbeatIncoming;\n            this.heartbeatOutgoing = config.heartbeatOutgoing;\n            this.splitLargeFrames = config.splitLargeFrames;\n            this.maxWebSocketChunkSize = config.maxWebSocketChunkSize;\n            this.forceBinaryWSFrames = config.forceBinaryWSFrames;\n            this.logRawCommunication = config.logRawCommunication;\n            this.appendMissingNULLonIncoming = config.appendMissingNULLonIncoming;\n            this.discardWebsocketOnCommFailure = config.discardWebsocketOnCommFailure;\n            this.onConnect = config.onConnect;\n            this.onDisconnect = config.onDisconnect;\n            this.onStompError = config.onStompError;\n            this.onWebSocketClose = config.onWebSocketClose;\n            this.onWebSocketError = config.onWebSocketError;\n            this.onUnhandledMessage = config.onUnhandledMessage;\n            this.onUnhandledReceipt = config.onUnhandledReceipt;\n            this.onUnhandledFrame = config.onUnhandledFrame;\n        }\n        get connectedVersion() {\n            return this._connectedVersion;\n        }\n        get connected() {\n            return this._connected;\n        }\n        start() {\n            const parser = new Parser(\n            // On Frame\n            rawFrame => {\n                const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\n                // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n                if (!this.logRawCommunication) {\n                    this.debug(`<<< ${frame}`);\n                }\n                const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n                serverFrameHandler(frame);\n            }, \n            // On Incoming Ping\n            () => {\n                this.debug('<<< PONG');\n            });\n            this._webSocket.onmessage = (evt) => {\n                this.debug('Received data');\n                this._lastServerActivityTS = Date.now();\n                if (this.logRawCommunication) {\n                    const rawChunkAsString = evt.data instanceof ArrayBuffer\n                        ? new TextDecoder().decode(evt.data)\n                        : evt.data;\n                    this.debug(`<<< ${rawChunkAsString}`);\n                }\n                parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n            };\n            this._webSocket.onclose = (closeEvent) => {\n                this.debug(`Connection closed to ${this._webSocket.url}`);\n                this._cleanUp();\n                this.onWebSocketClose(closeEvent);\n            };\n            this._webSocket.onerror = (errorEvent) => {\n                this.onWebSocketError(errorEvent);\n            };\n            this._webSocket.onopen = () => {\n                // Clone before updating\n                const connectHeaders = Object.assign({}, this.connectHeaders);\n                this.debug('Web Socket Opened...');\n                connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n                connectHeaders['heart-beat'] = [\n                    this.heartbeatOutgoing,\n                    this.heartbeatIncoming,\n                ].join(',');\n                this._transmit({ command: 'CONNECT', headers: connectHeaders });\n            };\n        }\n        _setupHeartbeat(headers) {\n            if (headers.version !== Versions.V1_1 &&\n                headers.version !== Versions.V1_2) {\n                return;\n            }\n            // It is valid for the server to not send this header\n            // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n            if (!headers['heart-beat']) {\n                return;\n            }\n            // heart-beat header received from the server looks like:\n            //\n            //     heart-beat: sx, sy\n            const [serverOutgoing, serverIncoming] = headers['heart-beat']\n                .split(',')\n                .map((v) => parseInt(v, 10));\n            if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n                const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n                this.debug(`send PING every ${ttl}ms`);\n                this._pinger = setInterval(() => {\n                    if (this._webSocket.readyState === exports.StompSocketState.OPEN) {\n                        this._webSocket.send(BYTE.LF);\n                        this.debug('>>> PING');\n                    }\n                }, ttl);\n            }\n            if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n                const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n                this.debug(`check PONG every ${ttl}ms`);\n                this._ponger = setInterval(() => {\n                    const delta = Date.now() - this._lastServerActivityTS;\n                    // We wait twice the TTL to be flexible on window's setInterval calls\n                    if (delta > ttl * 2) {\n                        this.debug(`did not receive server activity for the last ${delta}ms`);\n                        this._closeOrDiscardWebsocket();\n                    }\n                }, ttl);\n            }\n        }\n        _closeOrDiscardWebsocket() {\n            if (this.discardWebsocketOnCommFailure) {\n                this.debug('Discarding websocket, the underlying socket may linger for a while');\n                this.discardWebsocket();\n            }\n            else {\n                this.debug('Issuing close on the websocket');\n                this._closeWebsocket();\n            }\n        }\n        forceDisconnect() {\n            if (this._webSocket) {\n                if (this._webSocket.readyState === exports.StompSocketState.CONNECTING ||\n                    this._webSocket.readyState === exports.StompSocketState.OPEN) {\n                    this._closeOrDiscardWebsocket();\n                }\n            }\n        }\n        _closeWebsocket() {\n            this._webSocket.onmessage = () => { }; // ignore messages\n            this._webSocket.close();\n        }\n        discardWebsocket() {\n            if (typeof this._webSocket.terminate !== 'function') {\n                augmentWebsocket(this._webSocket, (msg) => this.debug(msg));\n            }\n            // @ts-ignore - this method will be there at this stage\n            this._webSocket.terminate();\n        }\n        _transmit(params) {\n            const { command, headers, body, binaryBody, skipContentLengthHeader } = params;\n            const frame = new FrameImpl({\n                command,\n                headers,\n                body,\n                binaryBody,\n                escapeHeaderValues: this._escapeHeaderValues,\n                skipContentLengthHeader,\n            });\n            let rawChunk = frame.serialize();\n            if (this.logRawCommunication) {\n                this.debug(`>>> ${rawChunk}`);\n            }\n            else {\n                this.debug(`>>> ${frame}`);\n            }\n            if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n                rawChunk = new TextEncoder().encode(rawChunk);\n            }\n            if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n                this._webSocket.send(rawChunk);\n            }\n            else {\n                let out = rawChunk;\n                while (out.length > 0) {\n                    const chunk = out.substring(0, this.maxWebSocketChunkSize);\n                    out = out.substring(this.maxWebSocketChunkSize);\n                    this._webSocket.send(chunk);\n                    this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n                }\n            }\n        }\n        dispose() {\n            if (this.connected) {\n                try {\n                    // clone before updating\n                    const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n                    if (!disconnectHeaders.receipt) {\n                        disconnectHeaders.receipt = `close-${this._counter++}`;\n                    }\n                    this.watchForReceipt(disconnectHeaders.receipt, frame => {\n                        this._closeWebsocket();\n                        this._cleanUp();\n                        this.onDisconnect(frame);\n                    });\n                    this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n                }\n                catch (error) {\n                    this.debug(`Ignoring error during disconnect ${error}`);\n                }\n            }\n            else {\n                if (this._webSocket.readyState === exports.StompSocketState.CONNECTING ||\n                    this._webSocket.readyState === exports.StompSocketState.OPEN) {\n                    this._closeWebsocket();\n                }\n            }\n        }\n        _cleanUp() {\n            this._connected = false;\n            if (this._pinger) {\n                clearInterval(this._pinger);\n                this._pinger = undefined;\n            }\n            if (this._ponger) {\n                clearInterval(this._ponger);\n                this._ponger = undefined;\n            }\n        }\n        publish(params) {\n            const { destination, headers, body, binaryBody, skipContentLengthHeader } = params;\n            const hdrs = Object.assign({ destination }, headers);\n            this._transmit({\n                command: 'SEND',\n                headers: hdrs,\n                body,\n                binaryBody,\n                skipContentLengthHeader,\n            });\n        }\n        watchForReceipt(receiptId, callback) {\n            this._receiptWatchers[receiptId] = callback;\n        }\n        subscribe(destination, callback, headers = {}) {\n            headers = Object.assign({}, headers);\n            if (!headers.id) {\n                headers.id = `sub-${this._counter++}`;\n            }\n            headers.destination = destination;\n            this._subscriptions[headers.id] = callback;\n            this._transmit({ command: 'SUBSCRIBE', headers });\n            const client = this;\n            return {\n                id: headers.id,\n                unsubscribe(hdrs) {\n                    return client.unsubscribe(headers.id, hdrs);\n                },\n            };\n        }\n        unsubscribe(id, headers = {}) {\n            headers = Object.assign({}, headers);\n            delete this._subscriptions[id];\n            headers.id = id;\n            this._transmit({ command: 'UNSUBSCRIBE', headers });\n        }\n        begin(transactionId) {\n            const txId = transactionId || `tx-${this._counter++}`;\n            this._transmit({\n                command: 'BEGIN',\n                headers: {\n                    transaction: txId,\n                },\n            });\n            const client = this;\n            return {\n                id: txId,\n                commit() {\n                    client.commit(txId);\n                },\n                abort() {\n                    client.abort(txId);\n                },\n            };\n        }\n        commit(transactionId) {\n            this._transmit({\n                command: 'COMMIT',\n                headers: {\n                    transaction: transactionId,\n                },\n            });\n        }\n        abort(transactionId) {\n            this._transmit({\n                command: 'ABORT',\n                headers: {\n                    transaction: transactionId,\n                },\n            });\n        }\n        ack(messageId, subscriptionId, headers = {}) {\n            headers = Object.assign({}, headers);\n            if (this._connectedVersion === Versions.V1_2) {\n                headers.id = messageId;\n            }\n            else {\n                headers['message-id'] = messageId;\n            }\n            headers.subscription = subscriptionId;\n            this._transmit({ command: 'ACK', headers });\n        }\n        nack(messageId, subscriptionId, headers = {}) {\n            headers = Object.assign({}, headers);\n            if (this._connectedVersion === Versions.V1_2) {\n                headers.id = messageId;\n            }\n            else {\n                headers['message-id'] = messageId;\n            }\n            headers.subscription = subscriptionId;\n            return this._transmit({ command: 'NACK', headers });\n        }\n    }\n\n    /**\n     * STOMP Client Class.\n     *\n     * Part of `@stomp/stompjs`.\n     */\n    class Client {\n        /**\n         * Create an instance.\n         */\n        constructor(conf = {}) {\n            /**\n             * STOMP versions to attempt during STOMP handshake. By default, versions `1.2`, `1.1`, and `1.0` are attempted.\n             *\n             * Example:\n             * ```javascript\n             *        // Try only versions 1.1 and 1.0\n             *        client.stompVersions = new Versions(['1.1', '1.0'])\n             * ```\n             */\n            this.stompVersions = Versions.default;\n            /**\n             * Will retry if Stomp connection is not established in specified milliseconds.\n             * Default 0, which switches off automatic reconnection.\n             */\n            this.connectionTimeout = 0;\n            /**\n             *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n             */\n            this.reconnectDelay = 5000;\n            /**\n             * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n             */\n            this.heartbeatIncoming = 10000;\n            /**\n             * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n             */\n            this.heartbeatOutgoing = 10000;\n            /**\n             * This switches on a non-standard behavior while sending WebSocket packets.\n             * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n             * Only Java Spring brokers seem to support this mode.\n             *\n             * WebSockets, by itself, split large (text) packets,\n             * so it is not needed with a truly compliant STOMP/WebSocket broker.\n             * Setting it for such a broker will cause large messages to fail.\n             *\n             * `false` by default.\n             *\n             * Binary frames are never split.\n             */\n            this.splitLargeFrames = false;\n            /**\n             * See [splitLargeFrames]{@link Client#splitLargeFrames}.\n             * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n             */\n            this.maxWebSocketChunkSize = 8 * 1024;\n            /**\n             * Usually the\n             * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\n             * is automatically decided by type of the payload.\n             * Default is `false`, which should work with all compliant brokers.\n             *\n             * Set this flag to force binary frames.\n             */\n            this.forceBinaryWSFrames = false;\n            /**\n             * A bug in ReactNative chops a string on occurrence of a NULL.\n             * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\n             * This makes incoming WebSocket messages invalid STOMP packets.\n             * Setting this flag attempts to reverse the damage by appending a NULL.\n             * If the broker splits a large message into multiple WebSocket messages,\n             * this flag will cause data loss and abnormal termination of connection.\n             *\n             * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\n             */\n            this.appendMissingNULLonIncoming = false;\n            /**\n             * Browsers do not immediately close WebSockets when `.close` is issued.\n             * This may cause reconnection to take a significantly long time in case\n             *  of some types of failures.\n             * In case of incoming heartbeat failure, this experimental flag instructs\n             * the library to discard the socket immediately\n             * (even before it is actually closed).\n             */\n            this.discardWebsocketOnCommFailure = false;\n            /**\n             * Activation state.\n             *\n             * It will usually be ACTIVE or INACTIVE.\n             * When deactivating, it may go from ACTIVE to INACTIVE without entering DEACTIVATING.\n             */\n            this.state = exports.ActivationState.INACTIVE;\n            // No op callbacks\n            const noOp = () => { };\n            this.debug = noOp;\n            this.beforeConnect = noOp;\n            this.onConnect = noOp;\n            this.onDisconnect = noOp;\n            this.onUnhandledMessage = noOp;\n            this.onUnhandledReceipt = noOp;\n            this.onUnhandledFrame = noOp;\n            this.onStompError = noOp;\n            this.onWebSocketClose = noOp;\n            this.onWebSocketError = noOp;\n            this.logRawCommunication = false;\n            this.onChangeState = noOp;\n            // These parameters would typically get proper values before connect is called\n            this.connectHeaders = {};\n            this._disconnectHeaders = {};\n            // Apply configuration\n            this.configure(conf);\n        }\n        /**\n         * Underlying WebSocket instance, READONLY.\n         */\n        get webSocket() {\n            return this._stompHandler?._webSocket;\n        }\n        /**\n         * Disconnection headers.\n         */\n        get disconnectHeaders() {\n            return this._disconnectHeaders;\n        }\n        set disconnectHeaders(value) {\n            this._disconnectHeaders = value;\n            if (this._stompHandler) {\n                this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n            }\n        }\n        /**\n         * `true` if there is an active connection to STOMP Broker\n         */\n        get connected() {\n            return !!this._stompHandler && this._stompHandler.connected;\n        }\n        /**\n         * version of STOMP protocol negotiated with the server, READONLY\n         */\n        get connectedVersion() {\n            return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n        }\n        /**\n         * if the client is active (connected or going to reconnect)\n         */\n        get active() {\n            return this.state === exports.ActivationState.ACTIVE;\n        }\n        _changeState(state) {\n            this.state = state;\n            this.onChangeState(state);\n        }\n        /**\n         * Update configuration.\n         */\n        configure(conf) {\n            // bulk assign all properties to this\n            Object.assign(this, conf);\n        }\n        /**\n         * Initiate the connection with the broker.\n         * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n         * it will keep trying to reconnect.\n         *\n         * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n         */\n        activate() {\n            const _activate = () => {\n                if (this.active) {\n                    this.debug('Already ACTIVE, ignoring request to activate');\n                    return;\n                }\n                this._changeState(exports.ActivationState.ACTIVE);\n                this._connect();\n            };\n            // if it is deactivating, wait for it to complete before activating.\n            if (this.state === exports.ActivationState.DEACTIVATING) {\n                this.debug('Waiting for deactivation to finish before activating');\n                this.deactivate().then(() => {\n                    _activate();\n                });\n            }\n            else {\n                _activate();\n            }\n        }\n        async _connect() {\n            await this.beforeConnect();\n            if (this._stompHandler) {\n                this.debug('There is already a stompHandler, skipping the call to connect');\n                return;\n            }\n            if (!this.active) {\n                this.debug('Client has been marked inactive, will not attempt to connect');\n                return;\n            }\n            // setup connection watcher\n            if (this.connectionTimeout > 0) {\n                // clear first\n                if (this._connectionWatcher) {\n                    clearTimeout(this._connectionWatcher);\n                }\n                this._connectionWatcher = setTimeout(() => {\n                    if (this.connected) {\n                        return;\n                    }\n                    // Connection not established, close the underlying socket\n                    // a reconnection will be attempted\n                    this.debug(`Connection not established in ${this.connectionTimeout}ms, closing socket`);\n                    this.forceDisconnect();\n                }, this.connectionTimeout);\n            }\n            this.debug('Opening Web Socket...');\n            // Get the actual WebSocket (or a similar object)\n            const webSocket = this._createWebSocket();\n            this._stompHandler = new StompHandler(this, webSocket, {\n                debug: this.debug,\n                stompVersions: this.stompVersions,\n                connectHeaders: this.connectHeaders,\n                disconnectHeaders: this._disconnectHeaders,\n                heartbeatIncoming: this.heartbeatIncoming,\n                heartbeatOutgoing: this.heartbeatOutgoing,\n                splitLargeFrames: this.splitLargeFrames,\n                maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n                forceBinaryWSFrames: this.forceBinaryWSFrames,\n                logRawCommunication: this.logRawCommunication,\n                appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\n                discardWebsocketOnCommFailure: this.discardWebsocketOnCommFailure,\n                onConnect: frame => {\n                    // Successfully connected, stop the connection watcher\n                    if (this._connectionWatcher) {\n                        clearTimeout(this._connectionWatcher);\n                        this._connectionWatcher = undefined;\n                    }\n                    if (!this.active) {\n                        this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n                        this._disposeStompHandler();\n                        return;\n                    }\n                    this.onConnect(frame);\n                },\n                onDisconnect: frame => {\n                    this.onDisconnect(frame);\n                },\n                onStompError: frame => {\n                    this.onStompError(frame);\n                },\n                onWebSocketClose: evt => {\n                    this._stompHandler = undefined; // a new one will be created in case of a reconnect\n                    if (this.state === exports.ActivationState.DEACTIVATING) {\n                        // Mark deactivation complete\n                        this._changeState(exports.ActivationState.INACTIVE);\n                    }\n                    // The callback is called before attempting to reconnect, this would allow the client\n                    // to be `deactivated` in the callback.\n                    this.onWebSocketClose(evt);\n                    if (this.active) {\n                        this._schedule_reconnect();\n                    }\n                },\n                onWebSocketError: evt => {\n                    this.onWebSocketError(evt);\n                },\n                onUnhandledMessage: message => {\n                    this.onUnhandledMessage(message);\n                },\n                onUnhandledReceipt: frame => {\n                    this.onUnhandledReceipt(frame);\n                },\n                onUnhandledFrame: frame => {\n                    this.onUnhandledFrame(frame);\n                },\n            });\n            this._stompHandler.start();\n        }\n        _createWebSocket() {\n            let webSocket;\n            if (this.webSocketFactory) {\n                webSocket = this.webSocketFactory();\n            }\n            else if (this.brokerURL) {\n                webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n            }\n            else {\n                throw new Error('Either brokerURL or webSocketFactory must be provided');\n            }\n            webSocket.binaryType = 'arraybuffer';\n            return webSocket;\n        }\n        _schedule_reconnect() {\n            if (this.reconnectDelay > 0) {\n                this.debug(`STOMP: scheduling reconnection in ${this.reconnectDelay}ms`);\n                this._reconnector = setTimeout(() => {\n                    this._connect();\n                }, this.reconnectDelay);\n            }\n        }\n        /**\n         * Disconnect if connected and stop auto reconnect loop.\n         * Appropriate callbacks will be invoked if there is an underlying STOMP connection.\n         *\n         * This call is async. It will resolve immediately if there is no underlying active websocket,\n         * otherwise, it will resolve after the underlying websocket is properly disposed of.\n         *\n         * It is not an error to invoke this method more than once.\n         * Each of those would resolve on completion of deactivation.\n         *\n         * To reactivate, you can call [Client#activate]{@link Client#activate}.\n         *\n         * Experimental: pass `force: true` to immediately discard the underlying connection.\n         * This mode will skip both the STOMP and the Websocket shutdown sequences.\n         * In some cases, browsers take a long time in the Websocket shutdown\n         * if the underlying connection had gone stale.\n         * Using this mode can speed up.\n         * When this mode is used, the actual Websocket may linger for a while\n         * and the broker may not realize that the connection is no longer in use.\n         *\n         * It is possible to invoke this method initially without the `force` option\n         * and subsequently, say after a wait, with the `force` option.\n         */\n        async deactivate(options = {}) {\n            const force = options.force || false;\n            const needToDispose = this.active;\n            let retPromise;\n            if (this.state === exports.ActivationState.INACTIVE) {\n                this.debug(`Already INACTIVE, nothing more to do`);\n                return Promise.resolve();\n            }\n            this._changeState(exports.ActivationState.DEACTIVATING);\n            // Clear if a reconnection was scheduled\n            if (this._reconnector) {\n                clearTimeout(this._reconnector);\n                this._reconnector = undefined;\n            }\n            if (this._stompHandler &&\n                // @ts-ignore - if there is a _stompHandler, there is the webSocket\n                this.webSocket.readyState !== exports.StompSocketState.CLOSED) {\n                const origOnWebSocketClose = this._stompHandler.onWebSocketClose;\n                // we need to wait for the underlying websocket to close\n                retPromise = new Promise((resolve, reject) => {\n                    // @ts-ignore - there is a _stompHandler\n                    this._stompHandler.onWebSocketClose = evt => {\n                        origOnWebSocketClose(evt);\n                        resolve();\n                    };\n                });\n            }\n            else {\n                // indicate that auto reconnect loop should terminate\n                this._changeState(exports.ActivationState.INACTIVE);\n                return Promise.resolve();\n            }\n            if (force) {\n                this._stompHandler?.discardWebsocket();\n            }\n            else if (needToDispose) {\n                this._disposeStompHandler();\n            }\n            return retPromise;\n        }\n        /**\n         * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n         * This is different from a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n         * After forcing disconnect, automatic reconnect will be attempted.\n         * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n         */\n        forceDisconnect() {\n            if (this._stompHandler) {\n                this._stompHandler.forceDisconnect();\n            }\n        }\n        _disposeStompHandler() {\n            // Dispose STOMP Handler\n            if (this._stompHandler) {\n                this._stompHandler.dispose();\n            }\n        }\n        /**\n         * Send a message to a named destination. Refer to your STOMP broker documentation for types\n         * and naming of destinations.\n         *\n         * STOMP protocol specifies and suggests some headers and also allows broker-specific headers.\n         *\n         * `body` must be String.\n         * You will need to covert the payload to string in case it is not string (e.g. JSON).\n         *\n         * To send a binary message body, use `binaryBody` parameter. It should be a\n         * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n         * Sometimes brokers may not support binary frames out of the box.\n         * Please check your broker documentation.\n         *\n         * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n         * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n         * For binary messages, `content-length` header is always added.\n         *\n         * Caution: The broker will, most likely, report an error and disconnect\n         * if the message body has NULL octet(s) and `content-length` header is missing.\n         *\n         * ```javascript\n         *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n         *\n         *        // Only destination is mandatory parameter\n         *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n         *\n         *        // Skip content-length header in the frame to the broker\n         *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n         *\n         *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n         *        // setting content-type header is not mandatory, however a good practice\n         *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n         *                         headers: {'content-type': 'application/octet-stream'}});\n         * ```\n         */\n        publish(params) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.publish(params);\n        }\n        _checkConnection() {\n            if (!this.connected) {\n                throw new TypeError('There is no underlying STOMP connection');\n            }\n        }\n        /**\n         * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n         * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n         * The value (say receipt-id) for this header needs to be unique for each use.\n         * Typically, a sequence, a UUID, a random number or a combination may be used.\n         *\n         * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n         * The operation needs to be matched based on the value of the receipt-id.\n         *\n         * This method allows watching for a receipt and invoking the callback\n         *  when the corresponding receipt has been received.\n         *\n         * The actual {@link IFrame} will be passed as parameter to the callback.\n         *\n         * Example:\n         * ```javascript\n         *        // Subscribing with acknowledgement\n         *        let receiptId = randomText();\n         *\n         *        client.watchForReceipt(receiptId, function() {\n         *          // Will be called after server acknowledges\n         *        });\n         *\n         *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n         *\n         *\n         *        // Publishing with acknowledgement\n         *        receiptId = randomText();\n         *\n         *        client.watchForReceipt(receiptId, function() {\n         *          // Will be called after server acknowledges\n         *        });\n         *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n         * ```\n         */\n        watchForReceipt(receiptId, callback) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.watchForReceipt(receiptId, callback);\n        }\n        /**\n         * Subscribe to a STOMP Broker location. The callback will be invoked for each\n         * received message with the {@link IMessage} as argument.\n         *\n         * Note: The library will generate a unique ID if there is none provided in the headers.\n         *       To use your own ID, pass it using the `headers` argument.\n         *\n         * ```javascript\n         *        callback = function(message) {\n         *        // called when the client receives a STOMP message from the server\n         *          if (message.body) {\n         *            alert(\"got message with body \" + message.body)\n         *          } else {\n         *            alert(\"got empty message\");\n         *          }\n         *        });\n         *\n         *        var subscription = client.subscribe(\"/queue/test\", callback);\n         *\n         *        // Explicit subscription id\n         *        var mySubId = 'my-subscription-id-001';\n         *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n         * ```\n         */\n        subscribe(destination, callback, headers = {}) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            return this._stompHandler.subscribe(destination, callback, headers);\n        }\n        /**\n         * It is preferable to unsubscribe from a subscription by calling\n         * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n         *\n         * ```javascript\n         *        var subscription = client.subscribe(destination, onmessage);\n         *        // ...\n         *        subscription.unsubscribe();\n         * ```\n         *\n         * See: https://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n         */\n        unsubscribe(id, headers = {}) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.unsubscribe(id, headers);\n        }\n        /**\n         * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\n         * and [abort]{@link ITransaction#abort}.\n         *\n         * `transactionId` is optional, if not passed the library will generate it internally.\n         */\n        begin(transactionId) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            return this._stompHandler.begin(transactionId);\n        }\n        /**\n         * Commit a transaction.\n         *\n         * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\n         * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n         *\n         * ```javascript\n         *        var tx = client.begin(txId);\n         *        //...\n         *        tx.commit();\n         * ```\n         */\n        commit(transactionId) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.commit(transactionId);\n        }\n        /**\n         * Abort a transaction.\n         * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\n         * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n         *\n         * ```javascript\n         *        var tx = client.begin(txId);\n         *        //...\n         *        tx.abort();\n         * ```\n         */\n        abort(transactionId) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.abort(transactionId);\n        }\n        /**\n         * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\n         * on the {@link IMessage} handled by a subscription callback:\n         *\n         * ```javascript\n         *        var callback = function (message) {\n         *          // process the message\n         *          // acknowledge it\n         *          message.ack();\n         *        };\n         *        client.subscribe(destination, callback, {'ack': 'client'});\n         * ```\n         */\n        ack(messageId, subscriptionId, headers = {}) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.ack(messageId, subscriptionId, headers);\n        }\n        /**\n         * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\n         * on the {@link IMessage} handled by a subscription callback:\n         *\n         * ```javascript\n         *        var callback = function (message) {\n         *          // process the message\n         *          // an error occurs, nack it\n         *          message.nack();\n         *        };\n         *        client.subscribe(destination, callback, {'ack': 'client'});\n         * ```\n         */\n        nack(messageId, subscriptionId, headers = {}) {\n            this._checkConnection();\n            // @ts-ignore - we already checked that there is a _stompHandler, and it is connected\n            this._stompHandler.nack(messageId, subscriptionId, headers);\n        }\n    }\n\n    /**\n     * Configuration options for STOMP Client, each key corresponds to\n     * field by the same name in {@link Client}. This can be passed to\n     * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\n     *\n     * Part of `@stomp/stompjs`.\n     */\n    class StompConfig {\n    }\n\n    /**\n     * STOMP headers. Many functions calls will accept headers as parameters.\n     * The headers sent by Broker will be available as [IFrame#headers]{@link IFrame#headers}.\n     *\n     * `key` and `value` must be valid strings.\n     * In addition, `key` must not contain `CR`, `LF`, or `:`.\n     *\n     * Part of `@stomp/stompjs`.\n     */\n    class StompHeaders {\n    }\n\n    /**\n     * Part of `@stomp/stompjs`.\n     *\n     * @internal\n     */\n    class HeartbeatInfo {\n        constructor(client) {\n            this.client = client;\n        }\n        get outgoing() {\n            return this.client.heartbeatOutgoing;\n        }\n        set outgoing(value) {\n            this.client.heartbeatOutgoing = value;\n        }\n        get incoming() {\n            return this.client.heartbeatIncoming;\n        }\n        set incoming(value) {\n            this.client.heartbeatIncoming = value;\n        }\n    }\n\n    /**\n     * Available for backward compatibility, please shift to using {@link Client}.\n     *\n     * **Deprecated**\n     *\n     * Part of `@stomp/stompjs`.\n     *\n     * To upgrade, please follow the [Upgrade Guide](https://stomp-js.github.io/guide/stompjs/upgrading-stompjs.html)\n     */\n    class CompatClient extends Client {\n        /**\n         * Available for backward compatibility, please shift to using {@link Client}\n         * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\n         *\n         * **Deprecated**\n         *\n         * @internal\n         */\n        constructor(webSocketFactory) {\n            super();\n            /**\n             * It is no op now. No longer needed. Large packets work out of the box.\n             */\n            this.maxWebSocketFrameSize = 16 * 1024;\n            this._heartbeatInfo = new HeartbeatInfo(this);\n            this.reconnect_delay = 0;\n            this.webSocketFactory = webSocketFactory;\n            // Default from previous version\n            this.debug = (...message) => {\n                console.log(...message);\n            };\n        }\n        _parseConnect(...args) {\n            let closeEventCallback;\n            let connectCallback;\n            let errorCallback;\n            let headers = {};\n            if (args.length < 2) {\n                throw new Error('Connect requires at least 2 arguments');\n            }\n            if (typeof args[1] === 'function') {\n                [headers, connectCallback, errorCallback, closeEventCallback] = args;\n            }\n            else {\n                switch (args.length) {\n                    case 6:\n                        [\n                            headers.login,\n                            headers.passcode,\n                            connectCallback,\n                            errorCallback,\n                            closeEventCallback,\n                            headers.host,\n                        ] = args;\n                        break;\n                    default:\n                        [\n                            headers.login,\n                            headers.passcode,\n                            connectCallback,\n                            errorCallback,\n                            closeEventCallback,\n                        ] = args;\n                }\n            }\n            return [headers, connectCallback, errorCallback, closeEventCallback];\n        }\n        /**\n         * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\n         *\n         * **Deprecated**\n         *\n         * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n         * version with headers to pass your broker specific options.\n         *\n         * overloads:\n         * - connect(headers, connectCallback)\n         * - connect(headers, connectCallback, errorCallback)\n         * - connect(login, passcode, connectCallback)\n         * - connect(login, passcode, connectCallback, errorCallback)\n         * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n         * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n         *\n         * params:\n         * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\n         * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\n         * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\n         * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\n         * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n         * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\n         * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n         *\n         * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n         */\n        connect(...args) {\n            const out = this._parseConnect(...args);\n            if (out[0]) {\n                this.connectHeaders = out[0];\n            }\n            if (out[1]) {\n                this.onConnect = out[1];\n            }\n            if (out[2]) {\n                this.onStompError = out[2];\n            }\n            if (out[3]) {\n                this.onWebSocketClose = out[3];\n            }\n            super.activate();\n        }\n        /**\n         * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\n         *\n         * **Deprecated**\n         *\n         * See:\n         * [Client#onDisconnect]{@link Client#onDisconnect}, and\n         * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\n         *\n         * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n         */\n        disconnect(disconnectCallback, headers = {}) {\n            if (disconnectCallback) {\n                this.onDisconnect = disconnectCallback;\n            }\n            this.disconnectHeaders = headers;\n            super.deactivate();\n        }\n        /**\n         * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\n         *\n         * Send a message to a named destination. Refer to your STOMP broker documentation for types\n         * and naming of destinations. The headers will, typically, be available to the subscriber.\n         * However, there may be special purpose headers corresponding to your STOMP broker.\n         *\n         *  **Deprecated**, use [Client#publish]{@link Client#publish}\n         *\n         * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n         *\n         * ```javascript\n         *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n         *\n         *        // If you want to send a message with a body, you must also pass the headers argument.\n         *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n         * ```\n         *\n         * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n         */\n        send(destination, headers = {}, body = '') {\n            headers = Object.assign({}, headers);\n            const skipContentLengthHeader = headers['content-length'] === false;\n            if (skipContentLengthHeader) {\n                delete headers['content-length'];\n            }\n            this.publish({\n                destination,\n                headers: headers,\n                body,\n                skipContentLengthHeader,\n            });\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\n         *\n         * **Deprecated**\n         */\n        set reconnect_delay(value) {\n            this.reconnectDelay = value;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\n         *\n         * **Deprecated**\n         */\n        get ws() {\n            return this.webSocket;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\n         *\n         * **Deprecated**\n         */\n        get version() {\n            return this.connectedVersion;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n         *\n         * **Deprecated**\n         */\n        get onreceive() {\n            return this.onUnhandledMessage;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n         *\n         * **Deprecated**\n         */\n        set onreceive(value) {\n            this.onUnhandledMessage = value;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n         * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\n         *\n         * **Deprecated**\n         */\n        get onreceipt() {\n            return this.onUnhandledReceipt;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n         *\n         * **Deprecated**\n         */\n        set onreceipt(value) {\n            this.onUnhandledReceipt = value;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n         * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n         *\n         * **Deprecated**\n         */\n        get heartbeat() {\n            return this._heartbeatInfo;\n        }\n        /**\n         * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n         * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n         *\n         * **Deprecated**\n         */\n        set heartbeat(value) {\n            this.heartbeatIncoming = value.incoming;\n            this.heartbeatOutgoing = value.outgoing;\n        }\n    }\n\n    /**\n     * STOMP Class, acts like a factory to create {@link Client}.\n     *\n     * Part of `@stomp/stompjs`.\n     *\n     * **Deprecated**\n     *\n     * It will be removed in next major version. Please switch to {@link Client}.\n     */\n    class Stomp {\n        /**\n         * This method creates a WebSocket client that is connected to\n         * the STOMP server located at the url.\n         *\n         * ```javascript\n         *        var url = \"ws://localhost:61614/stomp\";\n         *        var client = Stomp.client(url);\n         * ```\n         *\n         * **Deprecated**\n         *\n         * It will be removed in next major version. Please switch to {@link Client}\n         * using [Client#brokerURL]{@link Client#brokerURL}.\n         */\n        static client(url, protocols) {\n            // This is a hack to allow another implementation than the standard\n            // HTML5 WebSocket class.\n            //\n            // It is possible to use another class by calling\n            //\n            //     Stomp.WebSocketClass = MozWebSocket\n            //\n            // *prior* to call `Stomp.client()`.\n            //\n            // This hack is deprecated and `Stomp.over()` method should be used\n            // instead.\n            // See remarks on the function Stomp.over\n            if (protocols == null) {\n                protocols = Versions.default.protocolVersions();\n            }\n            const wsFn = () => {\n                const klass = Stomp.WebSocketClass || WebSocket;\n                return new klass(url, protocols);\n            };\n            return new CompatClient(wsFn);\n        }\n        /**\n         * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\n         * specify the WebSocket to use (either a standard HTML5 WebSocket or\n         * a similar object).\n         *\n         * In order to support reconnection, the function Client._connect should be callable more than once.\n         * While reconnecting\n         * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n         * alternatively allows passing a function that should return a new instance of the underlying socket.\n         *\n         * ```javascript\n         *        var client = Stomp.over(function(){\n         *          return new WebSocket('ws://localhost:15674/ws')\n         *        });\n         * ```\n         *\n         * **Deprecated**\n         *\n         * It will be removed in next major version. Please switch to {@link Client}\n         * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n         */\n        static over(ws) {\n            let wsFn;\n            if (typeof ws === 'function') {\n                wsFn = ws;\n            }\n            else {\n                console.warn('Stomp.over did not receive a factory, auto reconnect will not work. ' +\n                    'Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over');\n                wsFn = () => ws;\n            }\n            return new CompatClient(wsFn);\n        }\n    }\n    /**\n     * In case you need to use a non standard class for WebSocket.\n     *\n     * For example when using within NodeJS environment:\n     *\n     * ```javascript\n     *        StompJs = require('../../esm5/');\n     *        Stomp = StompJs.Stomp;\n     *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\n     * ```\n     *\n     * **Deprecated**\n     *\n     *\n     * It will be removed in next major version. Please switch to {@link Client}\n     * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n     */\n    // tslint:disable-next-line:variable-name\n    Stomp.WebSocketClass = null;\n\n    exports.Client = Client;\n    exports.CompatClient = CompatClient;\n    exports.FrameImpl = FrameImpl;\n    exports.Parser = Parser;\n    exports.Stomp = Stomp;\n    exports.StompConfig = StompConfig;\n    exports.StompHeaders = StompHeaders;\n    exports.Versions = Versions;\n\n}));\n"],"mappings":"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AAO,CAACC,OAAO,CAAC,CAAC;QAC5B;QACA,IAAIJ,KAAK,EAAE;UACPD,MAAI,CAACzB,aAAa,EAAEnC,gBAAgB,CAAC,CAAC;QAC1C,CAAC,MACI,IAAI8D,aAAa,EAAE;UACpBF,MAAI,CAACT,oBAAoB,CAAC,CAAC;QAC/B;QACA,OAAOY,UAAU;MAAC;IACtB;IACA;AACR;AACA;AACA;AACA;AACA;IACQ7D,eAAeA,CAAA,EAAG;MACd,IAAI,IAAI,CAACiC,aAAa,EAAE;QACpB,IAAI,CAACA,aAAa,CAACjC,eAAe,CAAC,CAAC;MACxC;IACJ;IACAiD,oBAAoBA,CAAA,EAAG;MACnB;MACA,IAAI,IAAI,CAAChB,aAAa,EAAE;QACpB,IAAI,CAACA,aAAa,CAAC5B,OAAO,CAAC,CAAC;MAChC;IACJ;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQK,OAAOA,CAACtN,MAAM,EAAE;MACZ,IAAI,CAAC+Q,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAACvB,OAAO,CAACtN,MAAM,CAAC;IACtC;IACA+Q,gBAAgBA,CAAA,EAAG;MACf,IAAI,CAAC,IAAI,CAAC/F,SAAS,EAAE;QACjB,MAAM,IAAIgG,SAAS,CAAC,yCAAyC,CAAC;MAClE;IACJ;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ7D,eAAeA,CAACM,SAAS,EAAEjE,QAAQ,EAAE;MACjC,IAAI,CAACuH,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAAC1B,eAAe,CAACM,SAAS,EAAEjE,QAAQ,CAAC;IAC3D;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQkE,SAASA,CAACH,WAAW,EAAE/D,QAAQ,EAAEtJ,OAAO,GAAG,CAAC,CAAC,EAAE;MAC3C,IAAI,CAAC6Q,gBAAgB,CAAC,CAAC;MACvB;MACA,OAAO,IAAI,CAAClC,aAAa,CAACnB,SAAS,CAACH,WAAW,EAAE/D,QAAQ,EAAEtJ,OAAO,CAAC;IACvE;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQyN,WAAWA,CAACzG,EAAE,EAAEhH,OAAO,GAAG,CAAC,CAAC,EAAE;MAC1B,IAAI,CAAC6Q,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAAClB,WAAW,CAACzG,EAAE,EAAEhH,OAAO,CAAC;IAC/C;IACA;AACR;AACA;AACA;AACA;AACA;IACQ0N,KAAKA,CAACC,aAAa,EAAE;MACjB,IAAI,CAACkD,gBAAgB,CAAC,CAAC;MACvB;MACA,OAAO,IAAI,CAAClC,aAAa,CAACjB,KAAK,CAACC,aAAa,CAAC;IAClD;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQG,MAAMA,CAACH,aAAa,EAAE;MAClB,IAAI,CAACkD,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAACb,MAAM,CAACH,aAAa,CAAC;IAC5C;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQI,KAAKA,CAACJ,aAAa,EAAE;MACjB,IAAI,CAACkD,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAACZ,KAAK,CAACJ,aAAa,CAAC;IAC3C;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQxE,GAAGA,CAACD,SAAS,EAAE8E,cAAc,EAAEhO,OAAO,GAAG,CAAC,CAAC,EAAE;MACzC,IAAI,CAAC6Q,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAACxF,GAAG,CAACD,SAAS,EAAE8E,cAAc,EAAEhO,OAAO,CAAC;IAC9D;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQoJ,IAAIA,CAACF,SAAS,EAAE8E,cAAc,EAAEhO,OAAO,GAAG,CAAC,CAAC,EAAE;MAC1C,IAAI,CAAC6Q,gBAAgB,CAAC,CAAC;MACvB;MACA,IAAI,CAAClC,aAAa,CAACvF,IAAI,CAACF,SAAS,EAAE8E,cAAc,EAAEhO,OAAO,CAAC;IAC/D;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAM+Q,WAAW,CAAC;;EAGlB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,YAAY,CAAC;;EAGnB;AACJ;AACA;AACA;AACA;EACI,MAAMC,aAAa,CAAC;IAChBpR,WAAWA,CAACoJ,MAAM,EAAE;MAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACxB;IACA,IAAIiI,QAAQA,CAAA,EAAG;MACX,OAAO,IAAI,CAACjI,MAAM,CAACkB,iBAAiB;IACxC;IACA,IAAI+G,QAAQA,CAAC3P,KAAK,EAAE;MAChB,IAAI,CAAC0H,MAAM,CAACkB,iBAAiB,GAAG5I,KAAK;IACzC;IACA,IAAI4P,QAAQA,CAAA,EAAG;MACX,OAAO,IAAI,CAAClI,MAAM,CAACiB,iBAAiB;IACxC;IACA,IAAIiH,QAAQA,CAAC5P,KAAK,EAAE;MAChB,IAAI,CAAC0H,MAAM,CAACiB,iBAAiB,GAAG3I,KAAK;IACzC;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM6P,YAAY,SAASnD,MAAM,CAAC;IAC9B;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQpO,WAAWA,CAACgQ,gBAAgB,EAAE;MAC1B,KAAK,CAAC,CAAC;MACP;AACZ;AACA;MACY,IAAI,CAACwB,qBAAqB,GAAG,EAAE,GAAG,IAAI;MACtC,IAAI,CAACC,cAAc,GAAG,IAAIL,aAAa,CAAC,IAAI,CAAC;MAC7C,IAAI,CAACM,eAAe,GAAG,CAAC;MACxB,IAAI,CAAC1B,gBAAgB,GAAGA,gBAAgB;MACxC;MACA,IAAI,CAACrJ,KAAK,GAAG,CAAC,GAAGwC,OAAO,KAAK;QACzBzD,OAAO,CAACC,GAAG,CAAC,GAAGwD,OAAO,CAAC;MAC3B,CAAC;IACL;IACAwI,aAAaA,CAAC,GAAGC,IAAI,EAAE;MACnB,IAAIC,kBAAkB;MACtB,IAAIC,eAAe;MACnB,IAAIC,aAAa;MACjB,IAAI5R,OAAO,GAAG,CAAC,CAAC;MAChB,IAAIyR,IAAI,CAAClP,MAAM,GAAG,CAAC,EAAE;QACjB,MAAM,IAAIyN,KAAK,CAAC,uCAAuC,CAAC;MAC5D;MACA,IAAI,OAAOyB,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;QAC/B,CAACzR,OAAO,EAAE2R,eAAe,EAAEC,aAAa,EAAEF,kBAAkB,CAAC,GAAGD,IAAI;MACxE,CAAC,MACI;QACD,QAAQA,IAAI,CAAClP,MAAM;UACf,KAAK,CAAC;YACF,CACIvC,OAAO,CAAC6R,KAAK,EACb7R,OAAO,CAAC8R,QAAQ,EAChBH,eAAe,EACfC,aAAa,EACbF,kBAAkB,EAClB1R,OAAO,CAAC+R,IAAI,CACf,GAAGN,IAAI;YACR;UACJ;YACI,CACIzR,OAAO,CAAC6R,KAAK,EACb7R,OAAO,CAAC8R,QAAQ,EAChBH,eAAe,EACfC,aAAa,EACbF,kBAAkB,CACrB,GAAGD,IAAI;QAChB;MACJ;MACA,OAAO,CAACzR,OAAO,EAAE2R,eAAe,EAAEC,aAAa,EAAEF,kBAAkB,CAAC;IACxE;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQM,OAAOA,CAAC,GAAGP,IAAI,EAAE;MACb,MAAM3E,GAAG,GAAG,IAAI,CAAC0E,aAAa,CAAC,GAAGC,IAAI,CAAC;MACvC,IAAI3E,GAAG,CAAC,CAAC,CAAC,EAAE;QACR,IAAI,CAAC9C,cAAc,GAAG8C,GAAG,CAAC,CAAC,CAAC;MAChC;MACA,IAAIA,GAAG,CAAC,CAAC,CAAC,EAAE;QACR,IAAI,CAACpE,SAAS,GAAGoE,GAAG,CAAC,CAAC,CAAC;MAC3B;MACA,IAAIA,GAAG,CAAC,CAAC,CAAC,EAAE;QACR,IAAI,CAACpD,YAAY,GAAGoD,GAAG,CAAC,CAAC,CAAC;MAC9B;MACA,IAAIA,GAAG,CAAC,CAAC,CAAC,EAAE;QACR,IAAI,CAACpC,gBAAgB,GAAGoC,GAAG,CAAC,CAAC,CAAC;MAClC;MACA,KAAK,CAACiC,QAAQ,CAAC,CAAC;IACpB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQkD,UAAUA,CAACC,kBAAkB,EAAElS,OAAO,GAAG,CAAC,CAAC,EAAE;MACzC,IAAIkS,kBAAkB,EAAE;QACpB,IAAI,CAACzH,YAAY,GAAGyH,kBAAkB;MAC1C;MACA,IAAI,CAACjI,iBAAiB,GAAGjK,OAAO;MAChC,KAAK,CAACmP,UAAU,CAAC,CAAC;IACtB;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ/C,IAAIA,CAACiB,WAAW,EAAErN,OAAO,GAAG,CAAC,CAAC,EAAEC,IAAI,GAAG,EAAE,EAAE;MACvCD,OAAO,GAAGK,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEN,OAAO,CAAC;MACpC,MAAMI,uBAAuB,GAAGJ,OAAO,CAAC,gBAAgB,CAAC,KAAK,KAAK;MACnE,IAAII,uBAAuB,EAAE;QACzB,OAAOJ,OAAO,CAAC,gBAAgB,CAAC;MACpC;MACA,IAAI,CAACoN,OAAO,CAAC;QACTC,WAAW;QACXrN,OAAO,EAAEA,OAAO;QAChBC,IAAI;QACJG;MACJ,CAAC,CAAC;IACN;IACA;AACR;AACA;AACA;AACA;IACQ,IAAImR,eAAeA,CAAChQ,KAAK,EAAE;MACvB,IAAI,CAAC6M,cAAc,GAAG7M,KAAK;IAC/B;IACA;AACR;AACA;AACA;AACA;IACQ,IAAI4Q,EAAEA,CAAA,EAAG;MACL,OAAO,IAAI,CAAC5L,SAAS;IACzB;IACA;AACR;AACA;AACA;AACA;IACQ,IAAIgC,OAAOA,CAAA,EAAG;MACV,OAAO,IAAI,CAACsC,gBAAgB;IAChC;IACA;AACR;AACA;AACA;AACA;IACQ,IAAIuH,SAASA,CAAA,EAAG;MACZ,OAAO,IAAI,CAACrJ,kBAAkB;IAClC;IACA;AACR;AACA;AACA;AACA;IACQ,IAAIqJ,SAASA,CAAC7Q,KAAK,EAAE;MACjB,IAAI,CAACwH,kBAAkB,GAAGxH,KAAK;IACnC;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI8Q,SAASA,CAAA,EAAG;MACZ,OAAO,IAAI,CAAC7I,kBAAkB;IAClC;IACA;AACR;AACA;AACA;AACA;IACQ,IAAI6I,SAASA,CAAC9Q,KAAK,EAAE;MACjB,IAAI,CAACiI,kBAAkB,GAAGjI,KAAK;IACnC;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI+Q,SAASA,CAAA,EAAG;MACZ,OAAO,IAAI,CAAChB,cAAc;IAC9B;IACA;AACR;AACA;AACA;AACA;AACA;IACQ,IAAIgB,SAASA,CAAC/Q,KAAK,EAAE;MACjB,IAAI,CAAC2I,iBAAiB,GAAG3I,KAAK,CAAC4P,QAAQ;MACvC,IAAI,CAAChH,iBAAiB,GAAG5I,KAAK,CAAC2P,QAAQ;IAC3C;EACJ;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMqB,KAAK,CAAC;IACR;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,OAAOtJ,MAAMA,CAACqC,GAAG,EAAEkH,SAAS,EAAE;MAC1B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIA,SAAS,IAAI,IAAI,EAAE;QACnBA,SAAS,GAAG5M,QAAQ,CAACS,OAAO,CAACN,gBAAgB,CAAC,CAAC;MACnD;MACA,MAAM0M,IAAI,GAAGA,CAAA,KAAM;QACf,MAAMC,KAAK,GAAGH,KAAK,CAACI,cAAc,IAAI5C,SAAS;QAC/C,OAAO,IAAI2C,KAAK,CAACpH,GAAG,EAAEkH,SAAS,CAAC;MACpC,CAAC;MACD,OAAO,IAAIpB,YAAY,CAACqB,IAAI,CAAC;IACjC;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,OAAOG,IAAIA,CAACT,EAAE,EAAE;MACZ,IAAIM,IAAI;MACR,IAAI,OAAON,EAAE,KAAK,UAAU,EAAE;QAC1BM,IAAI,GAAGN,EAAE;MACb,CAAC,MACI;QACD5M,OAAO,CAACsN,IAAI,CAAC,sEAAsE,GAC/E,+EAA+E,CAAC;QACpFJ,IAAI,GAAGA,CAAA,KAAMN,EAAE;MACnB;MACA,OAAO,IAAIf,YAAY,CAACqB,IAAI,CAAC;IACjC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;EACAF,KAAK,CAACI,cAAc,GAAG,IAAI;EAE3BzT,OAAO,CAAC+O,MAAM,GAAGA,MAAM;EACvB/O,OAAO,CAACkS,YAAY,GAAGA,YAAY;EACnClS,OAAO,CAACU,SAAS,GAAGA,SAAS;EAC7BV,OAAO,CAACiE,MAAM,GAAGA,MAAM;EACvBjE,OAAO,CAACqT,KAAK,GAAGA,KAAK;EACrBrT,OAAO,CAAC6R,WAAW,GAAGA,WAAW;EACjC7R,OAAO,CAAC8R,YAAY,GAAGA,YAAY;EACnC9R,OAAO,CAAC0G,QAAQ,GAAGA,QAAQ;AAE/B,CAAE,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}